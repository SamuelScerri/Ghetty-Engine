
# python wrapper for package samuelscerri/ghetty within overall package ghetty
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy.exe build -output=out -vm=python3 .

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _ghetty
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from ghetty import ghetty
# and then refer to everything using ghetty. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for slice [3]ghetty.Vertex
class Array_3_ghetty_Vertex(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ghetty.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ghetty.IncRef(self.handle)
	def __del__(self):
		_ghetty.DecRef(self.handle)
	def __str__(self):
		s = 'ghetty.Array_3_ghetty_Vertex len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'ghetty.Array_3_ghetty_Vertex([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _ghetty.Array_3_ghetty_Vertex_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Vertex(handle=_ghetty.Array_3_ghetty_Vertex_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_ghetty.Array_3_ghetty_Vertex_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Vertex(handle=_ghetty.Array_3_ghetty_Vertex_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration

# Python type for slice [4]*ebiten.Image
class Array_4_Ptr_ebiten_Image(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ghetty.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ghetty.IncRef(self.handle)
	def __del__(self):
		_ghetty.DecRef(self.handle)
	def __str__(self):
		s = 'ghetty.Array_4_Ptr_ebiten_Image len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'ghetty.Array_4_Ptr_ebiten_Image([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _ghetty.Array_4_Ptr_ebiten_Image_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_ebiten_Image(handle=_ghetty.Array_4_Ptr_ebiten_Image_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_ghetty.Array_4_Ptr_ebiten_Image_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_ebiten_Image(handle=_ghetty.Array_4_Ptr_ebiten_Image_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration

# Python type for slice []*ghetty.Matrix
class Slice_Ptr_ghetty_Matrix(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ghetty.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ghetty.IncRef(self.handle)
		else:
			self.handle = _ghetty.Slice_Ptr_ghetty_Matrix_CTor()
			_ghetty.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_ghetty_Matrix.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_ghetty.DecRef(self.handle)
	def __str__(self):
		s = 'ghetty.Slice_Ptr_ghetty_Matrix len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'ghetty.Slice_Ptr_ghetty_Matrix([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _ghetty.Slice_Ptr_ghetty_Matrix_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _ghetty.Slice_Ptr_ghetty_Matrix_len(self.handle)
				return Slice_Ptr_ghetty_Matrix(handle=_ghetty.Slice_Ptr_ghetty_Matrix_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Matrix(handle=_ghetty.Slice_Ptr_ghetty_Matrix_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_ghetty.Slice_Ptr_ghetty_Matrix_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_ghetty_Matrix.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Matrix(handle=_ghetty.Slice_Ptr_ghetty_Matrix_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_ghetty.Slice_Ptr_ghetty_Matrix_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*ghetty.ProcessedTriangle
class Slice_Ptr_ghetty_ProcessedTriangle(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ghetty.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ghetty.IncRef(self.handle)
		else:
			self.handle = _ghetty.Slice_Ptr_ghetty_ProcessedTriangle_CTor()
			_ghetty.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_ghetty_ProcessedTriangle.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_ghetty.DecRef(self.handle)
	def __str__(self):
		s = 'ghetty.Slice_Ptr_ghetty_ProcessedTriangle len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'ghetty.Slice_Ptr_ghetty_ProcessedTriangle([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _ghetty.Slice_Ptr_ghetty_ProcessedTriangle_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _ghetty.Slice_Ptr_ghetty_ProcessedTriangle_len(self.handle)
				return Slice_Ptr_ghetty_ProcessedTriangle(handle=_ghetty.Slice_Ptr_ghetty_ProcessedTriangle_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return ProcessedTriangle(handle=_ghetty.Slice_Ptr_ghetty_ProcessedTriangle_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_ghetty.Slice_Ptr_ghetty_ProcessedTriangle_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_ghetty_ProcessedTriangle.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = ProcessedTriangle(handle=_ghetty.Slice_Ptr_ghetty_ProcessedTriangle_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_ghetty.Slice_Ptr_ghetty_ProcessedTriangle_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []ebiten.Vertex
class Slice_ebiten_Vertex(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ghetty.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ghetty.IncRef(self.handle)
		else:
			self.handle = _ghetty.Slice_ebiten_Vertex_CTor()
			_ghetty.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_ebiten_Vertex.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_ghetty.DecRef(self.handle)
	def __str__(self):
		s = 'ghetty.Slice_ebiten_Vertex len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'ghetty.Slice_ebiten_Vertex([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _ghetty.Slice_ebiten_Vertex_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _ghetty.Slice_ebiten_Vertex_len(self.handle)
				return Slice_ebiten_Vertex(handle=_ghetty.Slice_ebiten_Vertex_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.ebiten_Vertex(handle=_ghetty.Slice_ebiten_Vertex_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_ghetty.Slice_ebiten_Vertex_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_ebiten_Vertex.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.ebiten_Vertex(handle=_ghetty.Slice_ebiten_Vertex_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_ghetty.Slice_ebiten_Vertex_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []fs.DirEntry
class Slice_fs_DirEntry(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ghetty.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ghetty.IncRef(self.handle)
		else:
			self.handle = _ghetty.Slice_fs_DirEntry_CTor()
			_ghetty.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_fs_DirEntry.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_ghetty.DecRef(self.handle)
	def __str__(self):
		s = 'ghetty.Slice_fs_DirEntry len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'ghetty.Slice_fs_DirEntry([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _ghetty.Slice_fs_DirEntry_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _ghetty.Slice_fs_DirEntry_len(self.handle)
				return Slice_fs_DirEntry(handle=_ghetty.Slice_fs_DirEntry_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.fs_DirEntry(handle=_ghetty.Slice_fs_DirEntry_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_ghetty.Slice_fs_DirEntry_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_fs_DirEntry.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.fs_DirEntry(handle=_ghetty.Slice_fs_DirEntry_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_ghetty.Slice_fs_DirEntry_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []fs.FileInfo
class Slice_fs_FileInfo(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ghetty.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ghetty.IncRef(self.handle)
		else:
			self.handle = _ghetty.Slice_fs_FileInfo_CTor()
			_ghetty.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_fs_FileInfo.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_ghetty.DecRef(self.handle)
	def __str__(self):
		s = 'ghetty.Slice_fs_FileInfo len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'ghetty.Slice_fs_FileInfo([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _ghetty.Slice_fs_FileInfo_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _ghetty.Slice_fs_FileInfo_len(self.handle)
				return Slice_fs_FileInfo(handle=_ghetty.Slice_fs_FileInfo_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.fs_FileInfo(handle=_ghetty.Slice_fs_FileInfo_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_ghetty.Slice_fs_FileInfo_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_fs_FileInfo.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.fs_FileInfo(handle=_ghetty.Slice_fs_FileInfo_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_ghetty.Slice_fs_FileInfo_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []ghetty.Tile
class Slice_ghetty_Tile(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ghetty.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ghetty.IncRef(self.handle)
		else:
			self.handle = _ghetty.Slice_ghetty_Tile_CTor()
			_ghetty.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_ghetty_Tile.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_ghetty.DecRef(self.handle)
	def __str__(self):
		s = 'ghetty.Slice_ghetty_Tile len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'ghetty.Slice_ghetty_Tile([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _ghetty.Slice_ghetty_Tile_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _ghetty.Slice_ghetty_Tile_len(self.handle)
				return Slice_ghetty_Tile(handle=_ghetty.Slice_ghetty_Tile_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Tile(handle=_ghetty.Slice_ghetty_Tile_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_ghetty.Slice_ghetty_Tile_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_ghetty_Tile.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Tile(handle=_ghetty.Slice_ghetty_Tile_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_ghetty.Slice_ghetty_Tile_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []ghetty.Triangle
class Slice_ghetty_Triangle(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ghetty.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ghetty.IncRef(self.handle)
		else:
			self.handle = _ghetty.Slice_ghetty_Triangle_CTor()
			_ghetty.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_ghetty_Triangle.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_ghetty.DecRef(self.handle)
	def __str__(self):
		s = 'ghetty.Slice_ghetty_Triangle len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'ghetty.Slice_ghetty_Triangle([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _ghetty.Slice_ghetty_Triangle_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _ghetty.Slice_ghetty_Triangle_len(self.handle)
				return Slice_ghetty_Triangle(handle=_ghetty.Slice_ghetty_Triangle_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Triangle(handle=_ghetty.Slice_ghetty_Triangle_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_ghetty.Slice_ghetty_Triangle_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_ghetty_Triangle.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Triangle(handle=_ghetty.Slice_ghetty_Triangle_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_ghetty.Slice_ghetty_Triangle_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for map map[string]any
class Map_string_any(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ghetty.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ghetty.IncRef(self.handle)
		else:
			self.handle = _ghetty.Map_string_any_CTor()
			_ghetty.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_any.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_ghetty.Map_string_any_set(self.handle, k, v)
	def __del__(self):
		_ghetty.DecRef(self.handle)
	def __str__(self):
		s = 'ghetty.Map_string_any len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'ghetty.Map_string_any({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _ghetty.Map_string_any_len(self.handle)
	def __getitem__(self, key):
		return any(handle=_ghetty.Map_string_any_elem(self.handle, key))
	def __setitem__(self, key, value):
		_ghetty.Map_string_any_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _ghetty.Map_string_any_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_ghetty.Map_string_any_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _ghetty.Map_string_any_contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---
A = 3
Aspect = 1.77778
B = 2
BarycentricAlgorithm = 0
EdgeTestAlgorithm = 1
FOV = 150
Far = 1000
G = 1
Height = 90
Near = 0.1
R = 0
RGBToFloat = 0.00392157
Scale = 4
SweepLineAlgorithm = 2
W = 3
Width = 160
X = 0
XMax = 0
XMin = 2
Y = 1
YMax = 1
YMin = 3
Z = 2


# ---- Global Variables: can only use functions to access ---
def AlgorithmUsed():
	"""
	AlgorithmUsed Gets Go Variable: ghetty.AlgorithmUsed
	
	"""
	return _ghetty.ghetty_AlgorithmUsed()

def Set_AlgorithmUsed(value):
	"""
	Set_AlgorithmUsed Sets Go Variable: ghetty.AlgorithmUsed
	
	"""
	if isinstance(value, go.GoClass):
		_ghetty.ghetty_Set_AlgorithmUsed(value.handle)
	else:
		_ghetty.ghetty_Set_AlgorithmUsed(value)

def Basic():
	"""
	Basic Gets Go Variable: ghetty.Basic
	
	"""
	return Shader(handle=_ghetty.ghetty_Basic())

def Set_Basic(value):
	"""
	Set_Basic Sets Go Variable: ghetty.Basic
	
	"""
	if isinstance(value, go.GoClass):
		_ghetty.ghetty_Set_Basic(value.handle)
	else:
		_ghetty.ghetty_Set_Basic(value)

def Brick():
	"""
	Brick Gets Go Variable: ghetty.Brick
	
	"""
	return Texture(handle=_ghetty.ghetty_Brick())

def Set_Brick(value):
	"""
	Set_Brick Sets Go Variable: ghetty.Brick
	
	"""
	if isinstance(value, go.GoClass):
		_ghetty.ghetty_Set_Brick(value.handle)
	else:
		_ghetty.ghetty_Set_Brick(value)

def Buffer():
	"""
	Buffer Gets Go Variable: ghetty.Buffer
	
	"""
	return go.Slice_byte(handle=_ghetty.ghetty_Buffer())

def Set_Buffer(value):
	"""
	Set_Buffer Sets Go Variable: ghetty.Buffer
	
	"""
	if isinstance(value, go.GoClass):
		_ghetty.ghetty_Set_Buffer(value.handle)
	else:
		_ghetty.ghetty_Set_Buffer(value)

def Bunny():
	"""
	Bunny Gets Go Variable: ghetty.Bunny
	
	"""
	return Model(handle=_ghetty.ghetty_Bunny())

def Set_Bunny(value):
	"""
	Set_Bunny Sets Go Variable: ghetty.Bunny
	
	"""
	if isinstance(value, go.GoClass):
		_ghetty.ghetty_Set_Bunny(value.handle)
	else:
		_ghetty.ghetty_Set_Bunny(value)

def Cobble():
	"""
	Cobble Gets Go Variable: ghetty.Cobble
	
	"""
	return Texture(handle=_ghetty.ghetty_Cobble())

def Set_Cobble(value):
	"""
	Set_Cobble Sets Go Variable: ghetty.Cobble
	
	"""
	if isinstance(value, go.GoClass):
		_ghetty.ghetty_Set_Cobble(value.handle)
	else:
		_ghetty.ghetty_Set_Cobble(value)

def Cores():
	"""
	Cores Gets Go Variable: ghetty.Cores
	
	"""
	return _ghetty.ghetty_Cores()

def Set_Cores(value):
	"""
	Set_Cores Sets Go Variable: ghetty.Cores
	
	"""
	if isinstance(value, go.GoClass):
		_ghetty.ghetty_Set_Cores(value.handle)
	else:
		_ghetty.ghetty_Set_Cores(value)

def Depth():
	"""
	Depth Gets Go Variable: ghetty.Depth
	
	"""
	return go.Slice_float32(handle=_ghetty.ghetty_Depth())

def Set_Depth(value):
	"""
	Set_Depth Sets Go Variable: ghetty.Depth
	
	"""
	if isinstance(value, go.GoClass):
		_ghetty.ghetty_Set_Depth(value.handle)
	else:
		_ghetty.ghetty_Set_Depth(value)

def Log():
	"""
	Log Gets Go Variable: ghetty.Log
	
	"""
	return Logger(handle=_ghetty.ghetty_Log())

def Set_Log(value):
	"""
	Set_Log Sets Go Variable: ghetty.Log
	
	"""
	if isinstance(value, go.GoClass):
		_ghetty.ghetty_Set_Log(value.handle)
	else:
		_ghetty.ghetty_Set_Log(value)

def Mutex():
	"""
	Mutex Gets Go Variable: ghetty.Mutex
	
	"""
	return go.sync_Mutex(handle=_ghetty.ghetty_Mutex())

def Set_Mutex(value):
	"""
	Set_Mutex Sets Go Variable: ghetty.Mutex
	
	"""
	if isinstance(value, go.GoClass):
		_ghetty.ghetty_Set_Mutex(value.handle)
	else:
		_ghetty.ghetty_Set_Mutex(value)

def Position():
	"""
	Position Gets Go Variable: ghetty.Position
	
	"""
	return Vertex(handle=_ghetty.ghetty_Position())

def Set_Position(value):
	"""
	Set_Position Sets Go Variable: ghetty.Position
	
	"""
	if isinstance(value, go.GoClass):
		_ghetty.ghetty_Set_Position(value.handle)
	else:
		_ghetty.ghetty_Set_Position(value)

def Projection():
	"""
	Projection Gets Go Variable: ghetty.Projection
	
	"""
	return Matrix(handle=_ghetty.ghetty_Projection())

def Set_Projection(value):
	"""
	Set_Projection Sets Go Variable: ghetty.Projection
	
	"""
	if isinstance(value, go.GoClass):
		_ghetty.ghetty_Set_Projection(value.handle)
	else:
		_ghetty.ghetty_Set_Projection(value)

def Scene():
	"""
	Scene Gets Go Variable: ghetty.Scene
	
	"""
	return _ghetty.ghetty_Scene()

def Set_Scene(value):
	"""
	Set_Scene Sets Go Variable: ghetty.Scene
	
	"""
	if isinstance(value, go.GoClass):
		_ghetty.ghetty_Set_Scene(value.handle)
	else:
		_ghetty.ghetty_Set_Scene(value)

def TileXSize():
	"""
	TileXSize Gets Go Variable: ghetty.TileXSize
	
	"""
	return _ghetty.ghetty_TileXSize()

def Set_TileXSize(value):
	"""
	Set_TileXSize Sets Go Variable: ghetty.TileXSize
	
	"""
	if isinstance(value, go.GoClass):
		_ghetty.ghetty_Set_TileXSize(value.handle)
	else:
		_ghetty.ghetty_Set_TileXSize(value)

def TileYSize():
	"""
	TileYSize Gets Go Variable: ghetty.TileYSize
	
	"""
	return _ghetty.ghetty_TileYSize()

def Set_TileYSize(value):
	"""
	Set_TileYSize Sets Go Variable: ghetty.TileYSize
	
	"""
	if isinstance(value, go.GoClass):
		_ghetty.ghetty_Set_TileYSize(value.handle)
	else:
		_ghetty.ghetty_Set_TileYSize(value)

def Tiles():
	"""
	Tiles Gets Go Variable: ghetty.Tiles
	
	"""
	return Slice_Slice_ghetty_Tile(handle=_ghetty.ghetty_Tiles())

def Set_Tiles(value):
	"""
	Set_Tiles Sets Go Variable: ghetty.Tiles
	
	"""
	if isinstance(value, go.GoClass):
		_ghetty.ghetty_Set_Tiles(value.handle)
	else:
		_ghetty.ghetty_Set_Tiles(value)

def Time():
	"""
	Time Gets Go Variable: ghetty.Time
	
	"""
	return _ghetty.ghetty_Time()

def Set_Time(value):
	"""
	Set_Time Sets Go Variable: ghetty.Time
	
	"""
	if isinstance(value, go.GoClass):
		_ghetty.ghetty_Set_Time(value.handle)
	else:
		_ghetty.ghetty_Set_Time(value)

def Triangles():
	"""
	Triangles Gets Go Variable: ghetty.Triangles
	
	"""
	return Slice_ghetty_Triangle(handle=_ghetty.ghetty_Triangles())

def Set_Triangles(value):
	"""
	Set_Triangles Sets Go Variable: ghetty.Triangles
	
	"""
	if isinstance(value, go.GoClass):
		_ghetty.ghetty_Set_Triangles(value.handle)
	else:
		_ghetty.ghetty_Set_Triangles(value)

def WaitGroup():
	"""
	WaitGroup Gets Go Variable: ghetty.WaitGroup
	
	"""
	return go.sync_WaitGroup(handle=_ghetty.ghetty_WaitGroup())

def Set_WaitGroup(value):
	"""
	Set_WaitGroup Sets Go Variable: ghetty.WaitGroup
	
	"""
	if isinstance(value, go.GoClass):
		_ghetty.ghetty_Set_WaitGroup(value.handle)
	else:
		_ghetty.ghetty_Set_WaitGroup(value)



# ---- Interfaces ---


# ---- Structs ---

# Python type for struct ghetty.Logger
class Logger(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ghetty.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ghetty.IncRef(self.handle)
		else:
			self.handle = _ghetty.ghetty_Logger_CTor()
			_ghetty.IncRef(self.handle)
			if  0 < len(args):
				self.File = args[0]
			if "File" in kwargs:
				self.File = kwargs["File"]
			if  1 < len(args):
				self.CurrentFPS = args[1]
			if "CurrentFPS" in kwargs:
				self.CurrentFPS = kwargs["CurrentFPS"]
			if  2 < len(args):
				self.ShouldWrite = args[2]
			if "ShouldWrite" in kwargs:
				self.ShouldWrite = kwargs["ShouldWrite"]
	def __del__(self):
		_ghetty.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ghetty.Logger{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ghetty.Logger ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def File(self):
		return go.Ptr_os_File(handle=_ghetty.ghetty_Logger_File_Get(self.handle))
	@File.setter
	def File(self, value):
		if isinstance(value, go.GoClass):
			_ghetty.ghetty_Logger_File_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def CurrentFPS(self):
		return _ghetty.ghetty_Logger_CurrentFPS_Get(self.handle)
	@CurrentFPS.setter
	def CurrentFPS(self, value):
		if isinstance(value, go.GoClass):
			_ghetty.ghetty_Logger_CurrentFPS_Set(self.handle, value.handle)
		else:
			_ghetty.ghetty_Logger_CurrentFPS_Set(self.handle, value)
	@property
	def ShouldWrite(self):
		return _ghetty.ghetty_Logger_ShouldWrite_Get(self.handle)
	@ShouldWrite.setter
	def ShouldWrite(self, value):
		if isinstance(value, go.GoClass):
			_ghetty.ghetty_Logger_ShouldWrite_Set(self.handle, value.handle)
		else:
			_ghetty.ghetty_Logger_ShouldWrite_Set(self.handle, value)
	def Log(self, framerate, goRun=False):
		"""Log(float framerate) """
		_ghetty.ghetty_Logger_Log(self.handle, framerate, goRun)
	def Close(self, goRun=False):
		"""Close() """
		_ghetty.ghetty_Logger_Close(self.handle, goRun)

# Python type for struct ghetty.ProcessedTriangle
class ProcessedTriangle(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ghetty.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ghetty.IncRef(self.handle)
		else:
			self.handle = _ghetty.ghetty_ProcessedTriangle_CTor()
			_ghetty.IncRef(self.handle)
			if  0 < len(args):
				self.Triangle = args[0]
			if "Triangle" in kwargs:
				self.Triangle = kwargs["Triangle"]
			if  1 < len(args):
				self.Bounds = args[1]
			if "Bounds" in kwargs:
				self.Bounds = kwargs["Bounds"]
			if  2 < len(args):
				self.VS1 = args[2]
			if "VS1" in kwargs:
				self.VS1 = kwargs["VS1"]
			if  3 < len(args):
				self.VS2 = args[3]
			if "VS2" in kwargs:
				self.VS2 = kwargs["VS2"]
			if  4 < len(args):
				self.Span = args[4]
			if "Span" in kwargs:
				self.Span = kwargs["Span"]
			if  5 < len(args):
				self.Split = args[5]
			if "Split" in kwargs:
				self.Split = kwargs["Split"]
	def __del__(self):
		_ghetty.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ghetty.ProcessedTriangle{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ghetty.ProcessedTriangle ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Triangle(self):
		return Triangle(handle=_ghetty.ghetty_ProcessedTriangle_Triangle_Get(self.handle))
	@Triangle.setter
	def Triangle(self, value):
		if isinstance(value, go.GoClass):
			_ghetty.ghetty_ProcessedTriangle_Triangle_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Bounds(self):
		return Vertex(handle=_ghetty.ghetty_ProcessedTriangle_Bounds_Get(self.handle))
	@Bounds.setter
	def Bounds(self, value):
		if isinstance(value, go.GoClass):
			_ghetty.ghetty_ProcessedTriangle_Bounds_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def VS1(self):
		return Vertex(handle=_ghetty.ghetty_ProcessedTriangle_VS1_Get(self.handle))
	@VS1.setter
	def VS1(self, value):
		if isinstance(value, go.GoClass):
			_ghetty.ghetty_ProcessedTriangle_VS1_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def VS2(self):
		return Vertex(handle=_ghetty.ghetty_ProcessedTriangle_VS2_Get(self.handle))
	@VS2.setter
	def VS2(self, value):
		if isinstance(value, go.GoClass):
			_ghetty.ghetty_ProcessedTriangle_VS2_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Span(self):
		return _ghetty.ghetty_ProcessedTriangle_Span_Get(self.handle)
	@Span.setter
	def Span(self, value):
		if isinstance(value, go.GoClass):
			_ghetty.ghetty_ProcessedTriangle_Span_Set(self.handle, value.handle)
		else:
			_ghetty.ghetty_ProcessedTriangle_Span_Set(self.handle, value)
	@property
	def Split(self):
		return _ghetty.ghetty_ProcessedTriangle_Split_Get(self.handle)
	@Split.setter
	def Split(self, value):
		if isinstance(value, go.GoClass):
			_ghetty.ghetty_ProcessedTriangle_Split_Set(self.handle, value.handle)
		else:
			_ghetty.ghetty_ProcessedTriangle_Split_Set(self.handle, value)

# Python type for struct ghetty.Shader
class Shader(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ghetty.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ghetty.IncRef(self.handle)
		else:
			self.handle = _ghetty.ghetty_Shader_CTor()
			_ghetty.IncRef(self.handle)
	def __del__(self):
		_ghetty.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ghetty.Shader{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ghetty.Shader ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct ghetty.Texture
class Texture(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ghetty.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ghetty.IncRef(self.handle)
		else:
			self.handle = _ghetty.ghetty_Texture_CTor()
			_ghetty.IncRef(self.handle)
			if  0 < len(args):
				self.Width = args[0]
			if "Width" in kwargs:
				self.Width = kwargs["Width"]
			if  1 < len(args):
				self.Height = args[1]
			if "Height" in kwargs:
				self.Height = kwargs["Height"]
			if  2 < len(args):
				self.Data = args[2]
			if "Data" in kwargs:
				self.Data = kwargs["Data"]
	def __del__(self):
		_ghetty.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ghetty.Texture{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ghetty.Texture ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Width(self):
		return _ghetty.ghetty_Texture_Width_Get(self.handle)
	@Width.setter
	def Width(self, value):
		if isinstance(value, go.GoClass):
			_ghetty.ghetty_Texture_Width_Set(self.handle, value.handle)
		else:
			_ghetty.ghetty_Texture_Width_Set(self.handle, value)
	@property
	def Height(self):
		return _ghetty.ghetty_Texture_Height_Get(self.handle)
	@Height.setter
	def Height(self, value):
		if isinstance(value, go.GoClass):
			_ghetty.ghetty_Texture_Height_Set(self.handle, value.handle)
		else:
			_ghetty.ghetty_Texture_Height_Set(self.handle, value)
	@property
	def Data(self):
		return go.Slice_byte(handle=_ghetty.ghetty_Texture_Data_Get(self.handle))
	@Data.setter
	def Data(self, value):
		if isinstance(value, go.GoClass):
			_ghetty.ghetty_Texture_Data_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def ConvertPosition(self, uv):
		"""ConvertPosition(object uv) int"""
		return _ghetty.ghetty_Texture_ConvertPosition(self.handle, uv.handle)

# Python type for struct ghetty.Tile
class Tile(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ghetty.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ghetty.IncRef(self.handle)
		else:
			self.handle = _ghetty.ghetty_Tile_CTor()
			_ghetty.IncRef(self.handle)
			if  0 < len(args):
				self.Frame = args[0]
			if "Frame" in kwargs:
				self.Frame = kwargs["Frame"]
			if  1 < len(args):
				self.Depth = args[1]
			if "Depth" in kwargs:
				self.Depth = kwargs["Depth"]
			if  2 < len(args):
				self.Triangles = args[2]
			if "Triangles" in kwargs:
				self.Triangles = kwargs["Triangles"]
			if  3 < len(args):
				self.X = args[3]
			if "X" in kwargs:
				self.X = kwargs["X"]
			if  4 < len(args):
				self.Y = args[4]
			if "Y" in kwargs:
				self.Y = kwargs["Y"]
	def __del__(self):
		_ghetty.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ghetty.Tile{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ghetty.Tile ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Frame(self):
		return go.Slice_byte(handle=_ghetty.ghetty_Tile_Frame_Get(self.handle))
	@Frame.setter
	def Frame(self, value):
		if isinstance(value, go.GoClass):
			_ghetty.ghetty_Tile_Frame_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Depth(self):
		return go.Slice_float32(handle=_ghetty.ghetty_Tile_Depth_Get(self.handle))
	@Depth.setter
	def Depth(self, value):
		if isinstance(value, go.GoClass):
			_ghetty.ghetty_Tile_Depth_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Triangles(self):
		return Slice_Ptr_ghetty_ProcessedTriangle(handle=_ghetty.ghetty_Tile_Triangles_Get(self.handle))
	@Triangles.setter
	def Triangles(self, value):
		if isinstance(value, go.GoClass):
			_ghetty.ghetty_Tile_Triangles_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def X(self):
		return _ghetty.ghetty_Tile_X_Get(self.handle)
	@X.setter
	def X(self, value):
		if isinstance(value, go.GoClass):
			_ghetty.ghetty_Tile_X_Set(self.handle, value.handle)
		else:
			_ghetty.ghetty_Tile_X_Set(self.handle, value)
	@property
	def Y(self):
		return _ghetty.ghetty_Tile_Y_Get(self.handle)
	@Y.setter
	def Y(self, value):
		if isinstance(value, go.GoClass):
			_ghetty.ghetty_Tile_Y_Set(self.handle, value.handle)
		else:
			_ghetty.ghetty_Tile_Y_Set(self.handle, value)
	def Barycentric(self, triangle, goRun=False):
		"""Barycentric(object triangle) """
		_ghetty.ghetty_Tile_Barycentric(self.handle, triangle.handle, goRun)
	def EdgeTest(self, triangle, goRun=False):
		"""EdgeTest(object triangle) """
		_ghetty.ghetty_Tile_EdgeTest(self.handle, triangle.handle, goRun)
	def SweepLine(self, triangle, goRun=False):
		"""SweepLine(object triangle) """
		_ghetty.ghetty_Tile_SweepLine(self.handle, triangle.handle, goRun)
	def Rasterize(self, goRun=False):
		"""Rasterize() """
		_ghetty.ghetty_Tile_Rasterize(self.handle, goRun)
	def Reset(self, goRun=False):
		"""Reset() """
		_ghetty.ghetty_Tile_Reset(self.handle, goRun)
	def Add(self, triangle, goRun=False):
		"""Add(object triangle) """
		_ghetty.ghetty_Tile_Add(self.handle, triangle.handle, goRun)
	def ConvertPosition(self, x, y):
		"""ConvertPosition(int x, int y) int"""
		return _ghetty.ghetty_Tile_ConvertPosition(self.handle, x, y)
	def Set(self, position, r, g, b, depth, goRun=False):
		"""Set(int position, int r, int g, int b, float depth) """
		_ghetty.ghetty_Tile_Set(self.handle, position, r, g, b, depth, goRun)
	def Clear(self, r, g, b, goRun=False):
		"""Clear(int r, int g, int b) """
		_ghetty.ghetty_Tile_Clear(self.handle, r, g, b, goRun)

# Python type for struct ghetty.Triangle
class Triangle(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ghetty.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ghetty.IncRef(self.handle)
		else:
			self.handle = _ghetty.ghetty_Triangle_CTor()
			_ghetty.IncRef(self.handle)
			if  0 < len(args):
				self.UV = args[0]
			if "UV" in kwargs:
				self.UV = kwargs["UV"]
			if  1 < len(args):
				self.Vertices = args[1]
			if "Vertices" in kwargs:
				self.Vertices = kwargs["Vertices"]
			if  2 < len(args):
				self.Color = args[2]
			if "Color" in kwargs:
				self.Color = kwargs["Color"]
			if  3 < len(args):
				self.Normals = args[3]
			if "Normals" in kwargs:
				self.Normals = kwargs["Normals"]
			if  4 < len(args):
				self.Texture = args[4]
			if "Texture" in kwargs:
				self.Texture = kwargs["Texture"]
			if  5 < len(args):
				self.Shader = args[5]
			if "Shader" in kwargs:
				self.Shader = kwargs["Shader"]
	def __del__(self):
		_ghetty.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ghetty.Triangle{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ghetty.Triangle ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def UV(self):
		return Array_3_ghetty_Vertex(handle=_ghetty.ghetty_Triangle_UV_Get(self.handle))
	@property
	def Vertices(self):
		return Array_3_ghetty_Vertex(handle=_ghetty.ghetty_Triangle_Vertices_Get(self.handle))
	@property
	def Color(self):
		return Array_3_ghetty_Vertex(handle=_ghetty.ghetty_Triangle_Color_Get(self.handle))
	@property
	def Normals(self):
		return Array_3_ghetty_Vertex(handle=_ghetty.ghetty_Triangle_Normals_Get(self.handle))
	@property
	def Texture(self):
		return Texture(handle=_ghetty.ghetty_Triangle_Texture_Get(self.handle))
	@Texture.setter
	def Texture(self, value):
		if isinstance(value, go.GoClass):
			_ghetty.ghetty_Triangle_Texture_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Shader(self):
		return Shader(handle=_ghetty.ghetty_Triangle_Shader_Get(self.handle))
	@Shader.setter
	def Shader(self, value):
		if isinstance(value, go.GoClass):
			_ghetty.ghetty_Triangle_Shader_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def Transform(self, m2, goRun=False):
		"""Transform(object m2) """
		_ghetty.ghetty_Triangle_Transform(self.handle, m2.handle, goRun)
	def ScreenSpace(self, goRun=False):
		"""ScreenSpace() """
		_ghetty.ghetty_Triangle_ScreenSpace(self.handle, goRun)
	def Normalize(self, goRun=False):
		"""Normalize() """
		_ghetty.ghetty_Triangle_Normalize(self.handle, goRun)
	def Sort(self, goRun=False):
		"""Sort() """
		_ghetty.ghetty_Triangle_Sort(self.handle, goRun)
	def Bounds(self):
		"""Bounds() []float"""
		return Vertex(handle=_ghetty.ghetty_Triangle_Bounds(self.handle))
	def Copy(self):
		"""Copy() object copiedTriangle"""
		return Triangle(handle=_ghetty.ghetty_Triangle_Copy(self.handle))

# Python type for struct ghetty.Game
class Game(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ghetty.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ghetty.IncRef(self.handle)
		else:
			self.handle = _ghetty.ghetty_Game_CTor()
			_ghetty.IncRef(self.handle)
	def __del__(self):
		_ghetty.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ghetty.Game{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ghetty.Game ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Update(self):
		"""Update() str"""
		return _ghetty.ghetty_Game_Update(self.handle)
	def Draw(self, screen, goRun=False):
		"""Draw(object screen) """
		_ghetty.ghetty_Game_Draw(self.handle, screen.handle, goRun)


# ---- Slices ---

# Python type for slice ghetty.Matrix
class Matrix(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ghetty.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ghetty.IncRef(self.handle)
		else:
			self.handle = _ghetty.ghetty_Matrix_CTor()
			_ghetty.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('ghetty_Matrix.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_ghetty.DecRef(self.handle)
	def __str__(self):
		s = 'ghetty.ghetty_Matrix len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'ghetty.ghetty_Matrix([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _ghetty.ghetty_Matrix_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _ghetty.ghetty_Matrix_len(self.handle)
				return Matrix(handle=_ghetty.ghetty_Matrix_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Slice_float32(handle=_ghetty.ghetty_Matrix_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_ghetty.ghetty_Matrix_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('ghetty_Matrix.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Slice_float32(handle=_ghetty.ghetty_Matrix_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_ghetty.ghetty_Matrix_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]
	def Multiply(self, m2):
		"""Multiply(object m2) [][]float"""
		return Matrix(handle=_ghetty.ghetty_Matrix_Multiply(self.handle, m2.handle))
	def Vertex(self):
		"""Vertex() []float"""
		return Vertex(handle=_ghetty.ghetty_Matrix_Vertex(self.handle))

# Python type for slice ghetty.Model
class Model(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ghetty.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ghetty.IncRef(self.handle)
		else:
			self.handle = _ghetty.ghetty_Model_CTor()
			_ghetty.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('ghetty_Model.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_ghetty.DecRef(self.handle)
	def __str__(self):
		s = 'ghetty.ghetty_Model len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'ghetty.ghetty_Model([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _ghetty.ghetty_Model_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _ghetty.ghetty_Model_len(self.handle)
				return Model(handle=_ghetty.ghetty_Model_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Triangle(handle=_ghetty.ghetty_Model_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_ghetty.ghetty_Model_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('ghetty_Model.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Triangle(handle=_ghetty.ghetty_Model_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_ghetty.ghetty_Model_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice ghetty.Vertex
class Vertex(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ghetty.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ghetty.IncRef(self.handle)
		else:
			self.handle = _ghetty.ghetty_Vertex_CTor()
			_ghetty.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('ghetty_Vertex.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_ghetty.DecRef(self.handle)
	def __str__(self):
		s = 'ghetty.ghetty_Vertex len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'ghetty.ghetty_Vertex([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _ghetty.ghetty_Vertex_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _ghetty.ghetty_Vertex_len(self.handle)
				return Vertex(handle=_ghetty.ghetty_Vertex_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _ghetty.ghetty_Vertex_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_ghetty.ghetty_Vertex_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('ghetty_Vertex.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _ghetty.ghetty_Vertex_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_ghetty.ghetty_Vertex_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]
	def Sum(self, v2, goRun=False):
		"""Sum(object v2) """
		_ghetty.ghetty_Vertex_Sum(self.handle, v2.handle, goRun)
	def Sub(self, v2, goRun=False):
		"""Sub(object v2) """
		_ghetty.ghetty_Vertex_Sub(self.handle, v2.handle, goRun)
	def Multiply(self, v2, goRun=False):
		"""Multiply(object v2) """
		_ghetty.ghetty_Vertex_Multiply(self.handle, v2.handle, goRun)
	def Transform(self, m2, goRun=False):
		"""Transform(object m2) """
		_ghetty.ghetty_Vertex_Transform(self.handle, m2.handle, goRun)
	def Dot(self, v2):
		"""Dot(object v2) float result"""
		return _ghetty.ghetty_Vertex_Dot(self.handle, v2.handle)
	def Cross(self, v2):
		"""Cross(object v2) []float"""
		return Vertex(handle=_ghetty.ghetty_Vertex_Cross(self.handle, v2.handle))
	def CrossProduct(self, v2):
		"""CrossProduct(object v2) float"""
		return _ghetty.ghetty_Vertex_CrossProduct(self.handle, v2.handle)
	def Interpolate(self, v2, factor, goRun=False):
		"""Interpolate(object v2, float factor) """
		_ghetty.ghetty_Vertex_Interpolate(self.handle, v2.handle, factor, goRun)
	def InsideClipSpace(self):
		"""InsideClipSpace() bool"""
		return _ghetty.ghetty_Vertex_InsideClipSpace(self.handle)
	def ScreenSpace(self, goRun=False):
		"""ScreenSpace() """
		_ghetty.ghetty_Vertex_ScreenSpace(self.handle, goRun)
	def Normalize(self, goRun=False):
		"""Normalize() """
		_ghetty.ghetty_Vertex_Normalize(self.handle, goRun)
	def Matrix(self):
		"""Matrix() [][]float"""
		return Matrix(handle=_ghetty.ghetty_Vertex_Matrix(self.handle))
	def Swap(self, v2, goRun=False):
		"""Swap(object v2) """
		_ghetty.ghetty_Vertex_Swap(self.handle, v2.handle, goRun)
	def Copy(self):
		"""Copy() []float copiedVertex"""
		return Vertex(handle=_ghetty.ghetty_Vertex_Copy(self.handle))


# ---- Maps ---


# ---- Constructors ---
def NewLogger(directory):
	"""NewLogger(str directory) object"""
	return Logger(handle=_ghetty.ghetty_NewLogger(directory))
def Process(triangle):
	"""Process(object triangle) object"""
	return ProcessedTriangle(handle=_ghetty.ghetty_Process(triangle.handle))
def LoadTexture(directory):
	"""LoadTexture(str directory) object"""
	return Texture(handle=_ghetty.ghetty_LoadTexture(directory))


# ---- Functions ---
def TransformationMatrix(p, r):
	"""TransformationMatrix([]float p, []float r) [][]float"""
	return Matrix(handle=_ghetty.ghetty_TransformationMatrix(p.handle, r.handle))
def BasicVertex(vertex, uv, normal, color, goRun=False, *args):
	"""BasicVertex(object vertex, object uv, object normal, object color, []object matrices) """
	matrices = Slice_Ptr_ghetty_Matrix(args)
	_ghetty.ghetty_BasicVertex(vertex.handle, uv.handle, normal.handle, color.handle, matrices.handle, goRun)
def Launch(goRun=False):
	"""Launch() """
	_ghetty.ghetty_Launch(goRun)
def LoadModel(directory):
	"""LoadModel(str directory) []object model"""
	return Model(handle=_ghetty.ghetty_LoadModel(directory))
def ProjectionMatrix():
	"""ProjectionMatrix() [][]float"""
	return Matrix(handle=_ghetty.ghetty_ProjectionMatrix())
def BuildAndProcess(triangle, tiles, goRun=False):
	"""BuildAndProcess(object triangle, object tiles) """
	_ghetty.ghetty_BuildAndProcess(triangle.handle, tiles.handle, goRun)
def Clamp(value, min, max):
	"""Clamp(float value, int min, int max) float"""
	return _ghetty.ghetty_Clamp(value, min, max)


