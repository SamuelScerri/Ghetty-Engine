/*
cgo stubs for package ghetty.
File is generated by gopy. Do not edit.
gopy.exe build -output=engine -vm=python3 .
*/

package main

/*

#cgo CFLAGS: -IC:/Python/Python312/Include -Wno-error -Wno-implicit-function-declaration -Wno-int-conversion
#cgo LDFLAGS: -LC:/Python/Python312/libs -lpython312

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"errors"
	"reflect"

	"github.com/go-python/gopy/gopyh" // handler

	"image"
	"image/color"
	"io"
	"io/fs"
	"os"
	"samuelscerri/ghetty"
	"sync"
	"syscall"
	"time"

	ebiten "github.com/hajimehoshi/ebiten/v2"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {

}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {

}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}

// errorGoToPy converts a Go error to python-compatible C.CString
func errorGoToPy(e error) *C.char {
	if e != nil {
		return C.CString(e.Error())
	}
	return C.CString("")
}

// --- generated code for package: ghetty below: ---

// ---- External Types Outside of Targeted Packages ---

// Converters for pointer handles for type: *ebiten.DrawImageOptions
func ptrFromHandle_Ptr_ebiten_DrawImageOptions(h CGoHandle) *ebiten.DrawImageOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ebiten.DrawImageOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ebiten.DrawImageOptions{})).(*ebiten.DrawImageOptions)
}
func handleFromPtr_Ptr_ebiten_DrawImageOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ebiten.DrawImageOptions", p))
}

// Converters for pointer handles for type: *ebiten.DrawRectShaderOptions
func ptrFromHandle_Ptr_ebiten_DrawRectShaderOptions(h CGoHandle) *ebiten.DrawRectShaderOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ebiten.DrawRectShaderOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ebiten.DrawRectShaderOptions{})).(*ebiten.DrawRectShaderOptions)
}
func handleFromPtr_Ptr_ebiten_DrawRectShaderOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ebiten.DrawRectShaderOptions", p))
}

// Converters for pointer handles for type: *ebiten.DrawTrianglesOptions
func ptrFromHandle_Ptr_ebiten_DrawTrianglesOptions(h CGoHandle) *ebiten.DrawTrianglesOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ebiten.DrawTrianglesOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ebiten.DrawTrianglesOptions{})).(*ebiten.DrawTrianglesOptions)
}
func handleFromPtr_Ptr_ebiten_DrawTrianglesOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ebiten.DrawTrianglesOptions", p))
}

// Converters for pointer handles for type: *ebiten.DrawTrianglesShaderOptions
func ptrFromHandle_Ptr_ebiten_DrawTrianglesShaderOptions(h CGoHandle) *ebiten.DrawTrianglesShaderOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ebiten.DrawTrianglesShaderOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ebiten.DrawTrianglesShaderOptions{})).(*ebiten.DrawTrianglesShaderOptions)
}
func handleFromPtr_Ptr_ebiten_DrawTrianglesShaderOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ebiten.DrawTrianglesShaderOptions", p))
}

// Converters for pointer handles for type: *ebiten.Image
func ptrFromHandle_Ptr_ebiten_Image(h CGoHandle) *ebiten.Image {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ebiten.Image")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ebiten.Image{})).(*ebiten.Image)
}
func handleFromPtr_Ptr_ebiten_Image(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ebiten.Image", p))
}

// Converters for pointer handles for type: *ebiten.Shader
func ptrFromHandle_Ptr_ebiten_Shader(h CGoHandle) *ebiten.Shader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ebiten.Shader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ebiten.Shader{})).(*ebiten.Shader)
}
func handleFromPtr_Ptr_ebiten_Shader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ebiten.Shader", p))
}

// Converters for pointer handles for type: *os.File
func ptrFromHandle_Ptr_os_File(h CGoHandle) *os.File {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*os.File")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(os.File{})).(*os.File)
}
func handleFromPtr_Ptr_os_File(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*os.File", p))
}

// Converters for pointer handles for type: *time.Location
func ptrFromHandle_Ptr_time_Location(h CGoHandle) *time.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*time.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Location{})).(*time.Location)
}
func handleFromPtr_Ptr_time_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*time.Location", p))
}

// Converters for non-pointer handles for type: ebiten.Blend
func ptrFromHandle_ebiten_Blend(h CGoHandle) *ebiten.Blend {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ebiten.Blend")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ebiten.Blend{})).(*ebiten.Blend)
}
func handleFromPtr_ebiten_Blend(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ebiten.Blend", p))
}

// Converters for non-pointer handles for type: ebiten.ColorM
func ptrFromHandle_ebiten_ColorM(h CGoHandle) *ebiten.ColorM {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ebiten.ColorM")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ebiten.ColorM{})).(*ebiten.ColorM)
}
func handleFromPtr_ebiten_ColorM(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ebiten.ColorM", p))
}

// Converters for non-pointer handles for type: ebiten.ColorScale
func ptrFromHandle_ebiten_ColorScale(h CGoHandle) *ebiten.ColorScale {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ebiten.ColorScale")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ebiten.ColorScale{})).(*ebiten.ColorScale)
}
func handleFromPtr_ebiten_ColorScale(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ebiten.ColorScale", p))
}

// Converters for non-pointer handles for type: ebiten.DrawImageOptions
func ptrFromHandle_ebiten_DrawImageOptions(h CGoHandle) *ebiten.DrawImageOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ebiten.DrawImageOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ebiten.DrawImageOptions{})).(*ebiten.DrawImageOptions)
}
func handleFromPtr_ebiten_DrawImageOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ebiten.DrawImageOptions", p))
}

// Converters for non-pointer handles for type: ebiten.DrawRectShaderOptions
func ptrFromHandle_ebiten_DrawRectShaderOptions(h CGoHandle) *ebiten.DrawRectShaderOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ebiten.DrawRectShaderOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ebiten.DrawRectShaderOptions{})).(*ebiten.DrawRectShaderOptions)
}
func handleFromPtr_ebiten_DrawRectShaderOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ebiten.DrawRectShaderOptions", p))
}

// Converters for non-pointer handles for type: ebiten.DrawTrianglesOptions
func ptrFromHandle_ebiten_DrawTrianglesOptions(h CGoHandle) *ebiten.DrawTrianglesOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ebiten.DrawTrianglesOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ebiten.DrawTrianglesOptions{})).(*ebiten.DrawTrianglesOptions)
}
func handleFromPtr_ebiten_DrawTrianglesOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ebiten.DrawTrianglesOptions", p))
}

// Converters for non-pointer handles for type: ebiten.DrawTrianglesShaderOptions
func ptrFromHandle_ebiten_DrawTrianglesShaderOptions(h CGoHandle) *ebiten.DrawTrianglesShaderOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ebiten.DrawTrianglesShaderOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ebiten.DrawTrianglesShaderOptions{})).(*ebiten.DrawTrianglesShaderOptions)
}
func handleFromPtr_ebiten_DrawTrianglesShaderOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ebiten.DrawTrianglesShaderOptions", p))
}

// Converters for non-pointer handles for type: ebiten.GeoM
func ptrFromHandle_ebiten_GeoM(h CGoHandle) *ebiten.GeoM {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ebiten.GeoM")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ebiten.GeoM{})).(*ebiten.GeoM)
}
func handleFromPtr_ebiten_GeoM(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ebiten.GeoM", p))
}

// Converters for non-pointer handles for type: ebiten.Image
func ptrFromHandle_ebiten_Image(h CGoHandle) *ebiten.Image {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ebiten.Image")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ebiten.Image{})).(*ebiten.Image)
}
func handleFromPtr_ebiten_Image(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ebiten.Image", p))
}

// Converters for non-pointer handles for type: ebiten.Shader
func ptrFromHandle_ebiten_Shader(h CGoHandle) *ebiten.Shader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ebiten.Shader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ebiten.Shader{})).(*ebiten.Shader)
}
func handleFromPtr_ebiten_Shader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ebiten.Shader", p))
}

// Converters for non-pointer handles for type: ebiten.Vertex
func ptrFromHandle_ebiten_Vertex(h CGoHandle) *ebiten.Vertex {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ebiten.Vertex")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ebiten.Vertex{})).(*ebiten.Vertex)
}
func handleFromPtr_ebiten_Vertex(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ebiten.Vertex", p))
}

// Converters for pointer handles for type: image.Image
func ptrFromHandle_image_Image(h CGoHandle) image.Image {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "image.Image")
	if p == nil {
		return nil
	}
	return p.(image.Image)
}
func handleFromPtr_image_Image(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("image.Image", p))
}

// Converters for non-pointer handles for type: image.Point
func ptrFromHandle_image_Point(h CGoHandle) *image.Point {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "image.Point")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(image.Point{})).(*image.Point)
}
func handleFromPtr_image_Point(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("image.Point", p))
}

// Converters for non-pointer handles for type: image.Rectangle
func ptrFromHandle_image_Rectangle(h CGoHandle) *image.Rectangle {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "image.Rectangle")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(image.Rectangle{})).(*image.Rectangle)
}
func handleFromPtr_image_Rectangle(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("image.Rectangle", p))
}

// Converters for pointer handles for type: color.Color
func ptrFromHandle_color_Color(h CGoHandle) color.Color {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "color.Color")
	if p == nil {
		return nil
	}
	return p.(color.Color)
}
func handleFromPtr_color_Color(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("color.Color", p))
}

// Converters for pointer handles for type: color.Model
func ptrFromHandle_color_Model(h CGoHandle) color.Model {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "color.Model")
	if p == nil {
		return nil
	}
	return p.(color.Model)
}
func handleFromPtr_color_Model(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("color.Model", p))
}

// Converters for non-pointer handles for type: color.RGBA64
func ptrFromHandle_color_RGBA64(h CGoHandle) *color.RGBA64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "color.RGBA64")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(color.RGBA64{})).(*color.RGBA64)
}
func handleFromPtr_color_RGBA64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("color.RGBA64", p))
}

// Converters for pointer handles for type: io.Reader
func ptrFromHandle_io_Reader(h CGoHandle) io.Reader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.Reader")
	if p == nil {
		return nil
	}
	return p.(io.Reader)
}
func handleFromPtr_io_Reader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.Reader", p))
}

// Converters for pointer handles for type: io.Writer
func ptrFromHandle_io_Writer(h CGoHandle) io.Writer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.Writer")
	if p == nil {
		return nil
	}
	return p.(io.Writer)
}
func handleFromPtr_io_Writer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.Writer", p))
}

// Converters for pointer handles for type: fs.DirEntry
func ptrFromHandle_fs_DirEntry(h CGoHandle) fs.DirEntry {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fs.DirEntry")
	if p == nil {
		return nil
	}
	return p.(fs.DirEntry)
}
func handleFromPtr_fs_DirEntry(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fs.DirEntry", p))
}

// Converters for pointer handles for type: fs.FileInfo
func ptrFromHandle_fs_FileInfo(h CGoHandle) fs.FileInfo {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fs.FileInfo")
	if p == nil {
		return nil
	}
	return p.(fs.FileInfo)
}
func handleFromPtr_fs_FileInfo(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fs.FileInfo", p))
}

// Converters for non-pointer handles for type: os.File
func ptrFromHandle_os_File(h CGoHandle) *os.File {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "os.File")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(os.File{})).(*os.File)
}
func handleFromPtr_os_File(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("os.File", p))
}

// Converters for non-pointer handles for type: sync.Mutex
func ptrFromHandle_sync_Mutex(h CGoHandle) *sync.Mutex {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "sync.Mutex")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(sync.Mutex{})).(*sync.Mutex)
}
func handleFromPtr_sync_Mutex(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("sync.Mutex", p))
}

// Converters for non-pointer handles for type: sync.WaitGroup
func ptrFromHandle_sync_WaitGroup(h CGoHandle) *sync.WaitGroup {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "sync.WaitGroup")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(sync.WaitGroup{})).(*sync.WaitGroup)
}
func handleFromPtr_sync_WaitGroup(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("sync.WaitGroup", p))
}

// Converters for pointer handles for type: syscall.RawConn
func ptrFromHandle_syscall_RawConn(h CGoHandle) syscall.RawConn {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "syscall.RawConn")
	if p == nil {
		return nil
	}
	return p.(syscall.RawConn)
}
func handleFromPtr_syscall_RawConn(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("syscall.RawConn", p))
}

// Converters for non-pointer handles for type: time.Location
func ptrFromHandle_time_Location(h CGoHandle) *time.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "time.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Location{})).(*time.Location)
}
func handleFromPtr_time_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("time.Location", p))
}

// Converters for non-pointer handles for type: time.Time
func ptrFromHandle_time_Time(h CGoHandle) *time.Time {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "time.Time")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Time{})).(*time.Time)
}
func handleFromPtr_time_Time(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("time.Time", p))
}

// ---- Package: go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func deptrFromHandle_Slice_bool(h CGoHandle) []bool {
	p := ptrFromHandle_Slice_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_subslice
func Slice_bool_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_bool(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_bool(&ss))
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}

// Converters for implicit pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func deptrFromHandle_Slice_byte(h CGoHandle) []byte {
	p := ptrFromHandle_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_subslice
func Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_byte(&ss))
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}

// Converters for implicit pointer handles for type: []error
func ptrFromHandle_Slice_error(h CGoHandle) *[]error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]error")
	if p == nil {
		return nil
	}
	return p.(*[]error)
}
func deptrFromHandle_Slice_error(h CGoHandle) []error {
	p := ptrFromHandle_Slice_error(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]error", p))
}

// --- wrapping slice: []error ---
//
//export Slice_error_CTor
func Slice_error_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_error(&[]error{}))
}

//export Slice_error_len
func Slice_error_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_error(handle))
}

//export Slice_error_elem
func Slice_error_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_error(handle)
	return errorGoToPy(s[_idx])
}

//export Slice_error_subslice
func Slice_error_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_error(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_error(&ss))
}

//export Slice_error_set
func Slice_error_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_error(handle)
	s[_idx] = errors.New(C.GoString(_vl))
}

//export Slice_error_append
func Slice_error_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_error(handle)
	*s = append(*s, errors.New(C.GoString(_vl)))
}

// Converters for implicit pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func deptrFromHandle_Slice_float32(h CGoHandle) []float32 {
	p := ptrFromHandle_Slice_float32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_subslice
func Slice_float32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float32(&ss))
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}

// Converters for implicit pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func deptrFromHandle_Slice_float64(h CGoHandle) []float64 {
	p := ptrFromHandle_Slice_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := deptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_subslice
func Slice_float64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float64(&ss))
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := deptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}

// Converters for implicit pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func deptrFromHandle_Slice_int(h CGoHandle) []int {
	p := ptrFromHandle_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_subslice
func Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int(&ss))
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func deptrFromHandle_Slice_int16(h CGoHandle) []int16 {
	p := ptrFromHandle_Slice_int16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := deptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_subslice
func Slice_int16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int16(&ss))
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := deptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}

// Converters for implicit pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func deptrFromHandle_Slice_int32(h CGoHandle) []int32 {
	p := ptrFromHandle_Slice_int32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_subslice
func Slice_int32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int32(&ss))
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}

// Converters for implicit pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func deptrFromHandle_Slice_int64(h CGoHandle) []int64 {
	p := ptrFromHandle_Slice_int64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_subslice
func Slice_int64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int64(&ss))
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}

// Converters for implicit pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func deptrFromHandle_Slice_int8(h CGoHandle) []int8 {
	p := ptrFromHandle_Slice_int8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_subslice
func Slice_int8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int8(&ss))
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}

// Converters for implicit pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func deptrFromHandle_Slice_rune(h CGoHandle) []rune {
	p := ptrFromHandle_Slice_rune(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_subslice
func Slice_rune_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_rune(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_rune(&ss))
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}

// Converters for implicit pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func deptrFromHandle_Slice_string(h CGoHandle) []string {
	p := ptrFromHandle_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_subslice
func Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_string(&ss))
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func deptrFromHandle_Slice_uint(h CGoHandle) []uint {
	p := ptrFromHandle_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_subslice
func Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint(&ss))
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}

// Converters for implicit pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func deptrFromHandle_Slice_uint16(h CGoHandle) []uint16 {
	p := ptrFromHandle_Slice_uint16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_subslice
func Slice_uint16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint16(&ss))
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}

// Converters for implicit pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func deptrFromHandle_Slice_uint32(h CGoHandle) []uint32 {
	p := ptrFromHandle_Slice_uint32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := deptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_subslice
func Slice_uint32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint32(&ss))
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := deptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}

// Converters for implicit pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func deptrFromHandle_Slice_uint64(h CGoHandle) []uint64 {
	p := ptrFromHandle_Slice_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_subslice
func Slice_uint64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint64(&ss))
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}

// Converters for implicit pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func deptrFromHandle_Slice_uint8(h CGoHandle) []uint8 {
	p := ptrFromHandle_Slice_uint8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := deptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_subslice
func Slice_uint8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint8(&ss))
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := deptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}

// ---- Package: ghetty ---

// ---- Types ---

// Converters for pointer handles for type: *[][]ghetty.Tile
func ptrFromHandle_Ptr_Slice_Slice_ghetty_Tile(h CGoHandle) *[][]ghetty.Tile {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*[][]ghetty.Tile")
	if p == nil {
		return nil
	}
	return p.(*[][]ghetty.Tile)
}
func handleFromPtr_Ptr_Slice_Slice_ghetty_Tile(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*[][]ghetty.Tile", p))
}

// Converters for pointer handles for type: *ghetty.Game
func ptrFromHandle_Ptr_ghetty_Game(h CGoHandle) *ghetty.Game {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ghetty.Game")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ghetty.Game{})).(*ghetty.Game)
}
func handleFromPtr_Ptr_ghetty_Game(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ghetty.Game", p))
}

// Converters for pointer handles for type: *ghetty.Logger
func ptrFromHandle_Ptr_ghetty_Logger(h CGoHandle) *ghetty.Logger {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ghetty.Logger")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ghetty.Logger{})).(*ghetty.Logger)
}
func handleFromPtr_Ptr_ghetty_Logger(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ghetty.Logger", p))
}

// Converters for pointer handles for type: *ghetty.Matrix
func ptrFromHandle_Ptr_ghetty_Matrix(h CGoHandle) *ghetty.Matrix {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ghetty.Matrix")
	if p == nil {
		return nil
	}
	return p.(*ghetty.Matrix)
}
func handleFromPtr_Ptr_ghetty_Matrix(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ghetty.Matrix", p))
}

// Converters for pointer handles for type: *ghetty.ProcessedTriangle
func ptrFromHandle_Ptr_ghetty_ProcessedTriangle(h CGoHandle) *ghetty.ProcessedTriangle {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ghetty.ProcessedTriangle")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ghetty.ProcessedTriangle{})).(*ghetty.ProcessedTriangle)
}
func handleFromPtr_Ptr_ghetty_ProcessedTriangle(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ghetty.ProcessedTriangle", p))
}

// Converters for pointer handles for type: *ghetty.Shader
func ptrFromHandle_Ptr_ghetty_Shader(h CGoHandle) *ghetty.Shader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ghetty.Shader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ghetty.Shader{})).(*ghetty.Shader)
}
func handleFromPtr_Ptr_ghetty_Shader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ghetty.Shader", p))
}

// Converters for pointer handles for type: *ghetty.Texture
func ptrFromHandle_Ptr_ghetty_Texture(h CGoHandle) *ghetty.Texture {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ghetty.Texture")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ghetty.Texture{})).(*ghetty.Texture)
}
func handleFromPtr_Ptr_ghetty_Texture(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ghetty.Texture", p))
}

// Converters for pointer handles for type: *ghetty.Tile
func ptrFromHandle_Ptr_ghetty_Tile(h CGoHandle) *ghetty.Tile {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ghetty.Tile")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ghetty.Tile{})).(*ghetty.Tile)
}
func handleFromPtr_Ptr_ghetty_Tile(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ghetty.Tile", p))
}

// Converters for pointer handles for type: *ghetty.Triangle
func ptrFromHandle_Ptr_ghetty_Triangle(h CGoHandle) *ghetty.Triangle {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ghetty.Triangle")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ghetty.Triangle{})).(*ghetty.Triangle)
}
func handleFromPtr_Ptr_ghetty_Triangle(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ghetty.Triangle", p))
}

// Converters for pointer handles for type: *ghetty.Vertex
func ptrFromHandle_Ptr_ghetty_Vertex(h CGoHandle) *ghetty.Vertex {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ghetty.Vertex")
	if p == nil {
		return nil
	}
	return p.(*ghetty.Vertex)
}
func handleFromPtr_Ptr_ghetty_Vertex(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ghetty.Vertex", p))
}

// Converters for implicit pointer handles for type: [3]ghetty.Vertex
func ptrFromHandle_Array_3_ghetty_Vertex(h CGoHandle) *[3]ghetty.Vertex {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[3]ghetty.Vertex")
	if p == nil {
		return nil
	}
	return p.(*[3]ghetty.Vertex)
}
func deptrFromHandle_Array_3_ghetty_Vertex(h CGoHandle) [3]ghetty.Vertex {
	p := ptrFromHandle_Array_3_ghetty_Vertex(h)
	return *p
}
func handleFromPtr_Array_3_ghetty_Vertex(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[3]ghetty.Vertex", p))
}

// --- wrapping slice: [3]ghetty.Vertex ---
//
//export Array_3_ghetty_Vertex_CTor
func Array_3_ghetty_Vertex_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Array_3_ghetty_Vertex(&[3]ghetty.Vertex{}))
}

//export Array_3_ghetty_Vertex_len
func Array_3_ghetty_Vertex_len(handle CGoHandle) int {
	return len(deptrFromHandle_Array_3_ghetty_Vertex(handle))
}

//export Array_3_ghetty_Vertex_elem
func Array_3_ghetty_Vertex_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Array_3_ghetty_Vertex(handle)
	return handleFromPtr_ghetty_Vertex(s[_idx])
}

//export Array_3_ghetty_Vertex_set
func Array_3_ghetty_Vertex_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Array_3_ghetty_Vertex(handle)
	s[_idx] = deptrFromHandle_ghetty_Vertex(_vl)
}

// Converters for implicit pointer handles for type: [4]*ebiten.Image
func ptrFromHandle_Array_4_Ptr_ebiten_Image(h CGoHandle) *[4]*ebiten.Image {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[4]*ebiten.Image")
	if p == nil {
		return nil
	}
	return p.(*[4]*ebiten.Image)
}
func deptrFromHandle_Array_4_Ptr_ebiten_Image(h CGoHandle) [4]*ebiten.Image {
	p := ptrFromHandle_Array_4_Ptr_ebiten_Image(h)
	return *p
}
func handleFromPtr_Array_4_Ptr_ebiten_Image(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[4]*ebiten.Image", p))
}

// --- wrapping slice: [4]*ebiten.Image ---
//
//export Array_4_Ptr_ebiten_Image_CTor
func Array_4_Ptr_ebiten_Image_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Array_4_Ptr_ebiten_Image(&[4]*ebiten.Image{}))
}

//export Array_4_Ptr_ebiten_Image_len
func Array_4_Ptr_ebiten_Image_len(handle CGoHandle) int {
	return len(deptrFromHandle_Array_4_Ptr_ebiten_Image(handle))
}

//export Array_4_Ptr_ebiten_Image_elem
func Array_4_Ptr_ebiten_Image_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Array_4_Ptr_ebiten_Image(handle)
	return handleFromPtr_Ptr_ebiten_Image(s[_idx])
}

//export Array_4_Ptr_ebiten_Image_set
func Array_4_Ptr_ebiten_Image_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Array_4_Ptr_ebiten_Image(handle)
	s[_idx] = ptrFromHandle_Ptr_ebiten_Image(_vl)
}

// Converters for implicit pointer handles for type: []*ghetty.Matrix
func ptrFromHandle_Slice_Ptr_ghetty_Matrix(h CGoHandle) *[]*ghetty.Matrix {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*ghetty.Matrix")
	if p == nil {
		return nil
	}
	return p.(*[]*ghetty.Matrix)
}
func deptrFromHandle_Slice_Ptr_ghetty_Matrix(h CGoHandle) []*ghetty.Matrix {
	p := ptrFromHandle_Slice_Ptr_ghetty_Matrix(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_ghetty_Matrix(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*ghetty.Matrix", p))
}

// --- wrapping slice: []*ghetty.Matrix ---
//
//export Slice_Ptr_ghetty_Matrix_CTor
func Slice_Ptr_ghetty_Matrix_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_ghetty_Matrix(&[]*ghetty.Matrix{}))
}

//export Slice_Ptr_ghetty_Matrix_len
func Slice_Ptr_ghetty_Matrix_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_ghetty_Matrix(handle))
}

//export Slice_Ptr_ghetty_Matrix_elem
func Slice_Ptr_ghetty_Matrix_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_ghetty_Matrix(handle)
	return handleFromPtr_Ptr_ghetty_Matrix(s[_idx])
}

//export Slice_Ptr_ghetty_Matrix_subslice
func Slice_Ptr_ghetty_Matrix_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_ghetty_Matrix(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_ghetty_Matrix(&ss))
}

//export Slice_Ptr_ghetty_Matrix_set
func Slice_Ptr_ghetty_Matrix_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_ghetty_Matrix(handle)
	s[_idx] = ptrFromHandle_Ptr_ghetty_Matrix(_vl)
}

//export Slice_Ptr_ghetty_Matrix_append
func Slice_Ptr_ghetty_Matrix_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_ghetty_Matrix(handle)
	*s = append(*s, ptrFromHandle_Ptr_ghetty_Matrix(_vl))
}

// Converters for implicit pointer handles for type: []*ghetty.ProcessedTriangle
func ptrFromHandle_Slice_Ptr_ghetty_ProcessedTriangle(h CGoHandle) *[]*ghetty.ProcessedTriangle {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*ghetty.ProcessedTriangle")
	if p == nil {
		return nil
	}
	return p.(*[]*ghetty.ProcessedTriangle)
}
func deptrFromHandle_Slice_Ptr_ghetty_ProcessedTriangle(h CGoHandle) []*ghetty.ProcessedTriangle {
	p := ptrFromHandle_Slice_Ptr_ghetty_ProcessedTriangle(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_ghetty_ProcessedTriangle(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*ghetty.ProcessedTriangle", p))
}

// --- wrapping slice: []*ghetty.ProcessedTriangle ---
//
//export Slice_Ptr_ghetty_ProcessedTriangle_CTor
func Slice_Ptr_ghetty_ProcessedTriangle_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_ghetty_ProcessedTriangle(&[]*ghetty.ProcessedTriangle{}))
}

//export Slice_Ptr_ghetty_ProcessedTriangle_len
func Slice_Ptr_ghetty_ProcessedTriangle_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_ghetty_ProcessedTriangle(handle))
}

//export Slice_Ptr_ghetty_ProcessedTriangle_elem
func Slice_Ptr_ghetty_ProcessedTriangle_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_ghetty_ProcessedTriangle(handle)
	return handleFromPtr_Ptr_ghetty_ProcessedTriangle(s[_idx])
}

//export Slice_Ptr_ghetty_ProcessedTriangle_subslice
func Slice_Ptr_ghetty_ProcessedTriangle_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_ghetty_ProcessedTriangle(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_ghetty_ProcessedTriangle(&ss))
}

//export Slice_Ptr_ghetty_ProcessedTriangle_set
func Slice_Ptr_ghetty_ProcessedTriangle_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_ghetty_ProcessedTriangle(handle)
	s[_idx] = ptrFromHandle_Ptr_ghetty_ProcessedTriangle(_vl)
}

//export Slice_Ptr_ghetty_ProcessedTriangle_append
func Slice_Ptr_ghetty_ProcessedTriangle_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_ghetty_ProcessedTriangle(handle)
	*s = append(*s, ptrFromHandle_Ptr_ghetty_ProcessedTriangle(_vl))
}

// Converters for implicit pointer handles for type: [][]ghetty.Tile
func ptrFromHandle_Slice_Slice_ghetty_Tile(h CGoHandle) *[][]ghetty.Tile {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[][]ghetty.Tile")
	if p == nil {
		return nil
	}
	return p.(*[][]ghetty.Tile)
}
func deptrFromHandle_Slice_Slice_ghetty_Tile(h CGoHandle) [][]ghetty.Tile {
	p := ptrFromHandle_Slice_Slice_ghetty_Tile(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Slice_ghetty_Tile(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[][]ghetty.Tile", p))
}

// Converters for implicit pointer handles for type: []ebiten.Vertex
func ptrFromHandle_Slice_ebiten_Vertex(h CGoHandle) *[]ebiten.Vertex {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]ebiten.Vertex")
	if p == nil {
		return nil
	}
	return p.(*[]ebiten.Vertex)
}
func deptrFromHandle_Slice_ebiten_Vertex(h CGoHandle) []ebiten.Vertex {
	p := ptrFromHandle_Slice_ebiten_Vertex(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_ebiten_Vertex(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]ebiten.Vertex", p))
}

// --- wrapping slice: []ebiten.Vertex ---
//
//export Slice_ebiten_Vertex_CTor
func Slice_ebiten_Vertex_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_ebiten_Vertex(&[]ebiten.Vertex{}))
}

//export Slice_ebiten_Vertex_len
func Slice_ebiten_Vertex_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_ebiten_Vertex(handle))
}

//export Slice_ebiten_Vertex_elem
func Slice_ebiten_Vertex_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_ebiten_Vertex(handle)
	return handleFromPtr_ebiten_Vertex(&(s[_idx]))
}

//export Slice_ebiten_Vertex_subslice
func Slice_ebiten_Vertex_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_ebiten_Vertex(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_ebiten_Vertex(&ss))
}

//export Slice_ebiten_Vertex_set
func Slice_ebiten_Vertex_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_ebiten_Vertex(handle)
	s[_idx] = *ptrFromHandle_ebiten_Vertex(_vl)
}

//export Slice_ebiten_Vertex_append
func Slice_ebiten_Vertex_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_ebiten_Vertex(handle)
	*s = append(*s, *ptrFromHandle_ebiten_Vertex(_vl))
}

// Converters for implicit pointer handles for type: []fs.DirEntry
func ptrFromHandle_Slice_fs_DirEntry(h CGoHandle) *[]fs.DirEntry {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]fs.DirEntry")
	if p == nil {
		return nil
	}
	return p.(*[]fs.DirEntry)
}
func deptrFromHandle_Slice_fs_DirEntry(h CGoHandle) []fs.DirEntry {
	p := ptrFromHandle_Slice_fs_DirEntry(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_fs_DirEntry(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]fs.DirEntry", p))
}

// --- wrapping slice: []fs.DirEntry ---
//
//export Slice_fs_DirEntry_CTor
func Slice_fs_DirEntry_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_fs_DirEntry(&[]fs.DirEntry{}))
}

//export Slice_fs_DirEntry_len
func Slice_fs_DirEntry_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_fs_DirEntry(handle))
}

//export Slice_fs_DirEntry_elem
func Slice_fs_DirEntry_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_fs_DirEntry(handle)
	return handleFromPtr_fs_DirEntry(s[_idx])
}

//export Slice_fs_DirEntry_subslice
func Slice_fs_DirEntry_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_fs_DirEntry(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_fs_DirEntry(&ss))
}

//export Slice_fs_DirEntry_set
func Slice_fs_DirEntry_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_fs_DirEntry(handle)
	s[_idx] = ptrFromHandle_fs_DirEntry(_vl)
}

//export Slice_fs_DirEntry_append
func Slice_fs_DirEntry_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_fs_DirEntry(handle)
	*s = append(*s, ptrFromHandle_fs_DirEntry(_vl))
}

// Converters for implicit pointer handles for type: []fs.FileInfo
func ptrFromHandle_Slice_fs_FileInfo(h CGoHandle) *[]fs.FileInfo {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]fs.FileInfo")
	if p == nil {
		return nil
	}
	return p.(*[]fs.FileInfo)
}
func deptrFromHandle_Slice_fs_FileInfo(h CGoHandle) []fs.FileInfo {
	p := ptrFromHandle_Slice_fs_FileInfo(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_fs_FileInfo(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]fs.FileInfo", p))
}

// --- wrapping slice: []fs.FileInfo ---
//
//export Slice_fs_FileInfo_CTor
func Slice_fs_FileInfo_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_fs_FileInfo(&[]fs.FileInfo{}))
}

//export Slice_fs_FileInfo_len
func Slice_fs_FileInfo_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_fs_FileInfo(handle))
}

//export Slice_fs_FileInfo_elem
func Slice_fs_FileInfo_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_fs_FileInfo(handle)
	return handleFromPtr_fs_FileInfo(s[_idx])
}

//export Slice_fs_FileInfo_subslice
func Slice_fs_FileInfo_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_fs_FileInfo(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_fs_FileInfo(&ss))
}

//export Slice_fs_FileInfo_set
func Slice_fs_FileInfo_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_fs_FileInfo(handle)
	s[_idx] = ptrFromHandle_fs_FileInfo(_vl)
}

//export Slice_fs_FileInfo_append
func Slice_fs_FileInfo_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_fs_FileInfo(handle)
	*s = append(*s, ptrFromHandle_fs_FileInfo(_vl))
}

// Converters for implicit pointer handles for type: []ghetty.Tile
func ptrFromHandle_Slice_ghetty_Tile(h CGoHandle) *[]ghetty.Tile {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]ghetty.Tile")
	if p == nil {
		return nil
	}
	return p.(*[]ghetty.Tile)
}
func deptrFromHandle_Slice_ghetty_Tile(h CGoHandle) []ghetty.Tile {
	p := ptrFromHandle_Slice_ghetty_Tile(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_ghetty_Tile(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]ghetty.Tile", p))
}

// --- wrapping slice: []ghetty.Tile ---
//
//export Slice_ghetty_Tile_CTor
func Slice_ghetty_Tile_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_ghetty_Tile(&[]ghetty.Tile{}))
}

//export Slice_ghetty_Tile_len
func Slice_ghetty_Tile_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_ghetty_Tile(handle))
}

//export Slice_ghetty_Tile_elem
func Slice_ghetty_Tile_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_ghetty_Tile(handle)
	return handleFromPtr_ghetty_Tile(&(s[_idx]))
}

//export Slice_ghetty_Tile_subslice
func Slice_ghetty_Tile_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_ghetty_Tile(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_ghetty_Tile(&ss))
}

//export Slice_ghetty_Tile_set
func Slice_ghetty_Tile_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_ghetty_Tile(handle)
	s[_idx] = *ptrFromHandle_ghetty_Tile(_vl)
}

//export Slice_ghetty_Tile_append
func Slice_ghetty_Tile_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_ghetty_Tile(handle)
	*s = append(*s, *ptrFromHandle_ghetty_Tile(_vl))
}

// Converters for implicit pointer handles for type: []ghetty.Triangle
func ptrFromHandle_Slice_ghetty_Triangle(h CGoHandle) *[]ghetty.Triangle {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]ghetty.Triangle")
	if p == nil {
		return nil
	}
	return p.(*[]ghetty.Triangle)
}
func deptrFromHandle_Slice_ghetty_Triangle(h CGoHandle) []ghetty.Triangle {
	p := ptrFromHandle_Slice_ghetty_Triangle(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_ghetty_Triangle(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]ghetty.Triangle", p))
}

// --- wrapping slice: []ghetty.Triangle ---
//
//export Slice_ghetty_Triangle_CTor
func Slice_ghetty_Triangle_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_ghetty_Triangle(&[]ghetty.Triangle{}))
}

//export Slice_ghetty_Triangle_len
func Slice_ghetty_Triangle_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_ghetty_Triangle(handle))
}

//export Slice_ghetty_Triangle_elem
func Slice_ghetty_Triangle_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_ghetty_Triangle(handle)
	return handleFromPtr_ghetty_Triangle(&(s[_idx]))
}

//export Slice_ghetty_Triangle_subslice
func Slice_ghetty_Triangle_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_ghetty_Triangle(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_ghetty_Triangle(&ss))
}

//export Slice_ghetty_Triangle_set
func Slice_ghetty_Triangle_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_ghetty_Triangle(handle)
	s[_idx] = *ptrFromHandle_ghetty_Triangle(_vl)
}

//export Slice_ghetty_Triangle_append
func Slice_ghetty_Triangle_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_ghetty_Triangle(handle)
	*s = append(*s, *ptrFromHandle_ghetty_Triangle(_vl))
}

// Converters for pointer handles for type: any
func ptrFromHandle_any(h CGoHandle) any {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "any")
	if p == nil {
		return nil
	}
	return p.(any)
}
func handleFromPtr_any(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("any", p))
}

// Converters for implicit pointer handles for type: map[string]any
func ptrFromHandle_Map_string_any(h CGoHandle) *map[string]any {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]any")
	if p == nil {
		return nil
	}
	return p.(*map[string]any)
}
func deptrFromHandle_Map_string_any(h CGoHandle) map[string]any {
	p := ptrFromHandle_Map_string_any(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_any(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]any", p))
}

// --- wrapping map: map[string]any ---
//
//export Map_string_any_CTor
func Map_string_any_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_any(&map[string]any{}))
}

//export Map_string_any_len
func Map_string_any_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_any(handle))
}

//export Map_string_any_elem
func Map_string_any_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_any(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_any(v)
}

//export Map_string_any_contains
func Map_string_any_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_any(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_any_set
func Map_string_any_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_any(handle)
	s[C.GoString(_ky)] = ptrFromHandle_any(_vl)
}

//export Map_string_any_delete
func Map_string_any_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_any(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_any_keys
func Map_string_any_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_any(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for non-pointer handles for type: ghetty.Game
func ptrFromHandle_ghetty_Game(h CGoHandle) *ghetty.Game {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ghetty.Game")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ghetty.Game{})).(*ghetty.Game)
}
func handleFromPtr_ghetty_Game(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ghetty.Game", p))
}

// Converters for non-pointer handles for type: ghetty.Logger
func ptrFromHandle_ghetty_Logger(h CGoHandle) *ghetty.Logger {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ghetty.Logger")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ghetty.Logger{})).(*ghetty.Logger)
}
func handleFromPtr_ghetty_Logger(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ghetty.Logger", p))
}

// Converters for implicit pointer handles for type: ghetty.Matrix
func ptrFromHandle_ghetty_Matrix(h CGoHandle) *ghetty.Matrix {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ghetty.Matrix")
	if p == nil {
		return nil
	}
	return p.(*ghetty.Matrix)
}
func deptrFromHandle_ghetty_Matrix(h CGoHandle) ghetty.Matrix {
	p := ptrFromHandle_ghetty_Matrix(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_ghetty_Matrix(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ghetty.Matrix", p))
}

// Converters for implicit pointer handles for type: ghetty.Model
func ptrFromHandle_ghetty_Model(h CGoHandle) *ghetty.Model {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ghetty.Model")
	if p == nil {
		return nil
	}
	return p.(*ghetty.Model)
}
func deptrFromHandle_ghetty_Model(h CGoHandle) ghetty.Model {
	p := ptrFromHandle_ghetty_Model(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_ghetty_Model(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ghetty.Model", p))
}

// Converters for non-pointer handles for type: ghetty.ProcessedTriangle
func ptrFromHandle_ghetty_ProcessedTriangle(h CGoHandle) *ghetty.ProcessedTriangle {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ghetty.ProcessedTriangle")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ghetty.ProcessedTriangle{})).(*ghetty.ProcessedTriangle)
}
func handleFromPtr_ghetty_ProcessedTriangle(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ghetty.ProcessedTriangle", p))
}

// Converters for non-pointer handles for type: ghetty.Shader
func ptrFromHandle_ghetty_Shader(h CGoHandle) *ghetty.Shader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ghetty.Shader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ghetty.Shader{})).(*ghetty.Shader)
}
func handleFromPtr_ghetty_Shader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ghetty.Shader", p))
}

// Converters for non-pointer handles for type: ghetty.Texture
func ptrFromHandle_ghetty_Texture(h CGoHandle) *ghetty.Texture {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ghetty.Texture")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ghetty.Texture{})).(*ghetty.Texture)
}
func handleFromPtr_ghetty_Texture(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ghetty.Texture", p))
}

// Converters for non-pointer handles for type: ghetty.Tile
func ptrFromHandle_ghetty_Tile(h CGoHandle) *ghetty.Tile {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ghetty.Tile")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ghetty.Tile{})).(*ghetty.Tile)
}
func handleFromPtr_ghetty_Tile(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ghetty.Tile", p))
}

// Converters for non-pointer handles for type: ghetty.Triangle
func ptrFromHandle_ghetty_Triangle(h CGoHandle) *ghetty.Triangle {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ghetty.Triangle")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ghetty.Triangle{})).(*ghetty.Triangle)
}
func handleFromPtr_ghetty_Triangle(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ghetty.Triangle", p))
}

// Converters for implicit pointer handles for type: ghetty.Vertex
func ptrFromHandle_ghetty_Vertex(h CGoHandle) *ghetty.Vertex {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ghetty.Vertex")
	if p == nil {
		return nil
	}
	return p.(*ghetty.Vertex)
}
func deptrFromHandle_ghetty_Vertex(h CGoHandle) ghetty.Vertex {
	p := ptrFromHandle_ghetty_Vertex(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_ghetty_Vertex(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ghetty.Vertex", p))
}

// ---- Global Variables: can only use functions to access ---
//
//export ghetty_AlgorithmUsed
func ghetty_AlgorithmUsed() C.longlong {
	return C.longlong(ghetty.AlgorithmUsed)
}

//export ghetty_Set_AlgorithmUsed
func ghetty_Set_AlgorithmUsed(val C.longlong) {
	ghetty.AlgorithmUsed = int(val)
}

//export ghetty_Basic
func ghetty_Basic() CGoHandle {
	return handleFromPtr_ghetty_Shader(&ghetty.Basic)
}

//export ghetty_Set_Basic
func ghetty_Set_Basic(val CGoHandle) {
	ghetty.Basic = *ptrFromHandle_ghetty_Shader(val)
}

//export ghetty_Brick
func ghetty_Brick() CGoHandle {
	return handleFromPtr_ghetty_Texture(&ghetty.Brick)
}

//export ghetty_Set_Brick
func ghetty_Set_Brick(val CGoHandle) {
	ghetty.Brick = *ptrFromHandle_ghetty_Texture(val)
}

//export ghetty_Buffer
func ghetty_Buffer() CGoHandle {
	return handleFromPtr_Slice_byte(&ghetty.Buffer)
}

//export ghetty_Set_Buffer
func ghetty_Set_Buffer(val CGoHandle) {
	ghetty.Buffer = deptrFromHandle_Slice_byte(val)
}

//export ghetty_Bunny
func ghetty_Bunny() CGoHandle {
	return handleFromPtr_ghetty_Model(&ghetty.Bunny)
}

//export ghetty_Set_Bunny
func ghetty_Set_Bunny(val CGoHandle) {
	ghetty.Bunny = deptrFromHandle_ghetty_Model(val)
}

//export ghetty_Cobble
func ghetty_Cobble() CGoHandle {
	return handleFromPtr_ghetty_Texture(&ghetty.Cobble)
}

//export ghetty_Set_Cobble
func ghetty_Set_Cobble(val CGoHandle) {
	ghetty.Cobble = *ptrFromHandle_ghetty_Texture(val)
}

//export ghetty_Cores
func ghetty_Cores() C.longlong {
	return C.longlong(ghetty.Cores)
}

//export ghetty_Set_Cores
func ghetty_Set_Cores(val C.longlong) {
	ghetty.Cores = int(val)
}

//export ghetty_Depth
func ghetty_Depth() CGoHandle {
	return handleFromPtr_Slice_float32(&ghetty.Depth)
}

//export ghetty_Set_Depth
func ghetty_Set_Depth(val CGoHandle) {
	ghetty.Depth = deptrFromHandle_Slice_float32(val)
}

//export ghetty_EncodedImage
func ghetty_EncodedImage() *C.char {
	return C.CString(ghetty.EncodedImage)
}

//export ghetty_Set_EncodedImage
func ghetty_Set_EncodedImage(val *C.char) {
	ghetty.EncodedImage = C.GoString(val)
}

//export ghetty_Log
func ghetty_Log() CGoHandle {
	return handleFromPtr_ghetty_Logger(&ghetty.Log)
}

//export ghetty_Set_Log
func ghetty_Set_Log(val CGoHandle) {
	ghetty.Log = *ptrFromHandle_ghetty_Logger(val)
}

//export ghetty_Mutex
func ghetty_Mutex() CGoHandle {
	return handleFromPtr_sync_Mutex(&ghetty.Mutex)
}

//export ghetty_Set_Mutex
func ghetty_Set_Mutex(val CGoHandle) {
	ghetty.Mutex = *ptrFromHandle_sync_Mutex(val)
}

//export ghetty_Position
func ghetty_Position() CGoHandle {
	return handleFromPtr_ghetty_Vertex(&ghetty.Position)
}

//export ghetty_Set_Position
func ghetty_Set_Position(val CGoHandle) {
	ghetty.Position = deptrFromHandle_ghetty_Vertex(val)
}

//export ghetty_Projection
func ghetty_Projection() CGoHandle {
	return handleFromPtr_ghetty_Matrix(&ghetty.Projection)
}

//export ghetty_Set_Projection
func ghetty_Set_Projection(val CGoHandle) {
	ghetty.Projection = deptrFromHandle_ghetty_Matrix(val)
}

//export ghetty_Scene
func ghetty_Scene() C.longlong {
	return C.longlong(ghetty.Scene)
}

//export ghetty_Set_Scene
func ghetty_Set_Scene(val C.longlong) {
	ghetty.Scene = int(val)
}

//export ghetty_TileXSize
func ghetty_TileXSize() C.longlong {
	return C.longlong(ghetty.TileXSize)
}

//export ghetty_Set_TileXSize
func ghetty_Set_TileXSize(val C.longlong) {
	ghetty.TileXSize = int(val)
}

//export ghetty_TileYSize
func ghetty_TileYSize() C.longlong {
	return C.longlong(ghetty.TileYSize)
}

//export ghetty_Set_TileYSize
func ghetty_Set_TileYSize(val C.longlong) {
	ghetty.TileYSize = int(val)
}

//export ghetty_Tiles
func ghetty_Tiles() CGoHandle {
	return handleFromPtr_Slice_Slice_ghetty_Tile(&ghetty.Tiles)
}

//export ghetty_Set_Tiles
func ghetty_Set_Tiles(val CGoHandle) {
	ghetty.Tiles = deptrFromHandle_Slice_Slice_ghetty_Tile(val)
}

//export ghetty_Time
func ghetty_Time() C.float {
	return C.float(ghetty.Time)
}

//export ghetty_Set_Time
func ghetty_Set_Time(val C.float) {
	ghetty.Time = float32(val)
}

//export ghetty_Triangles
func ghetty_Triangles() CGoHandle {
	return handleFromPtr_Slice_ghetty_Triangle(&ghetty.Triangles)
}

//export ghetty_Set_Triangles
func ghetty_Set_Triangles(val CGoHandle) {
	ghetty.Triangles = deptrFromHandle_Slice_ghetty_Triangle(val)
}

//export ghetty_UpscaledBuffer
func ghetty_UpscaledBuffer() CGoHandle {
	return handleFromPtr_Slice_byte(&ghetty.UpscaledBuffer)
}

//export ghetty_Set_UpscaledBuffer
func ghetty_Set_UpscaledBuffer(val CGoHandle) {
	ghetty.UpscaledBuffer = deptrFromHandle_Slice_byte(val)
}

//export ghetty_WaitGroup
func ghetty_WaitGroup() CGoHandle {
	return handleFromPtr_sync_WaitGroup(&ghetty.WaitGroup)
}

//export ghetty_Set_WaitGroup
func ghetty_Set_WaitGroup(val CGoHandle) {
	ghetty.WaitGroup = *ptrFromHandle_sync_WaitGroup(val)
}

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: ghetty.Triangle ---
//
//export ghetty_Triangle_CTor
func ghetty_Triangle_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ghetty_Triangle(&ghetty.Triangle{}))
}

//export ghetty_Triangle_UV_Get
func ghetty_Triangle_UV_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ghetty_Triangle(handle)
	return handleFromPtr_Array_3_ghetty_Vertex(&op.UV)
}

//export ghetty_Triangle_Vertices_Get
func ghetty_Triangle_Vertices_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ghetty_Triangle(handle)
	return handleFromPtr_Array_3_ghetty_Vertex(&op.Vertices)
}

//export ghetty_Triangle_Color_Get
func ghetty_Triangle_Color_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ghetty_Triangle(handle)
	return handleFromPtr_Array_3_ghetty_Vertex(&op.Color)
}

//export ghetty_Triangle_Normals_Get
func ghetty_Triangle_Normals_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ghetty_Triangle(handle)
	return handleFromPtr_Array_3_ghetty_Vertex(&op.Normals)
}

//export ghetty_Triangle_Texture_Get
func ghetty_Triangle_Texture_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ghetty_Triangle(handle)
	return handleFromPtr_Ptr_ghetty_Texture(op.Texture)
}

//export ghetty_Triangle_Texture_Set
func ghetty_Triangle_Texture_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_ghetty_Triangle(handle)
	op.Texture = ptrFromHandle_Ptr_ghetty_Texture(val)
}

//export ghetty_Triangle_Shader_Get
func ghetty_Triangle_Shader_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ghetty_Triangle(handle)
	return handleFromPtr_Ptr_ghetty_Shader(op.Shader)
}

//export ghetty_Triangle_Shader_Set
func ghetty_Triangle_Shader_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_ghetty_Triangle(handle)
	op.Shader = ptrFromHandle_Ptr_ghetty_Shader(val)
}

//export ghetty_Triangle_Transform
func ghetty_Triangle_Transform(_handle CGoHandle, m2 CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Triangle")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ghetty.Triangle{})).(*ghetty.Triangle).Transform(ptrFromHandle_Ptr_ghetty_Matrix(m2))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ghetty.Triangle{})).(*ghetty.Triangle).Transform(ptrFromHandle_Ptr_ghetty_Matrix(m2))
	}
}

//export ghetty_Triangle_ScreenSpace
func ghetty_Triangle_ScreenSpace(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Triangle")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ghetty.Triangle{})).(*ghetty.Triangle).ScreenSpace()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ghetty.Triangle{})).(*ghetty.Triangle).ScreenSpace()
	}
}

//export ghetty_Triangle_Normalize
func ghetty_Triangle_Normalize(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Triangle")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ghetty.Triangle{})).(*ghetty.Triangle).Normalize()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ghetty.Triangle{})).(*ghetty.Triangle).Normalize()
	}
}

//export ghetty_Triangle_Sort
func ghetty_Triangle_Sort(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Triangle")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ghetty.Triangle{})).(*ghetty.Triangle).Sort()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ghetty.Triangle{})).(*ghetty.Triangle).Sort()
	}
}

//export ghetty_Triangle_Bounds
func ghetty_Triangle_Bounds(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Triangle")
	if __err != nil {
		return handleFromPtr_ghetty_Vertex(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(ghetty.Triangle{})).(*ghetty.Triangle).Bounds()

	return handleFromPtr_ghetty_Vertex(&cret)
}

//export ghetty_Triangle_Copy
func ghetty_Triangle_Copy(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Triangle")
	if __err != nil {
		return handleFromPtr_ghetty_Triangle(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(ghetty.Triangle{})).(*ghetty.Triangle).Copy()

	return handleFromPtr_ghetty_Triangle(&cret)
}

// --- wrapping struct: ghetty.Game ---
//
//export ghetty_Game_CTor
func ghetty_Game_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ghetty_Game(&ghetty.Game{}))
}

//export ghetty_Game_Update
func ghetty_Game_Update(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Game")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(ghetty.Game{})).(*ghetty.Game).Update()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export ghetty_Game_Draw
func ghetty_Game_Draw(_handle CGoHandle, screen CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Game")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ghetty.Game{})).(*ghetty.Game).Draw(ptrFromHandle_Ptr_ebiten_Image(screen))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ghetty.Game{})).(*ghetty.Game).Draw(ptrFromHandle_Ptr_ebiten_Image(screen))
	}
}

// --- wrapping struct: ghetty.Logger ---
//
//export ghetty_Logger_CTor
func ghetty_Logger_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ghetty_Logger(&ghetty.Logger{}))
}

//export ghetty_Logger_File_Get
func ghetty_Logger_File_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ghetty_Logger(handle)
	return handleFromPtr_Ptr_os_File(op.File)
}

//export ghetty_Logger_File_Set
func ghetty_Logger_File_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_ghetty_Logger(handle)
	op.File = ptrFromHandle_Ptr_os_File(val)
}

//export ghetty_Logger_CurrentFPS_Get
func ghetty_Logger_CurrentFPS_Get(handle CGoHandle) C.double {
	op := ptrFromHandle_ghetty_Logger(handle)
	return C.double(op.CurrentFPS)
}

//export ghetty_Logger_CurrentFPS_Set
func ghetty_Logger_CurrentFPS_Set(handle CGoHandle, val C.double) {
	op := ptrFromHandle_ghetty_Logger(handle)
	op.CurrentFPS = float64(val)
}

//export ghetty_Logger_ShouldWrite_Get
func ghetty_Logger_ShouldWrite_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_ghetty_Logger(handle)
	return boolGoToPy(op.ShouldWrite)
}

//export ghetty_Logger_ShouldWrite_Set
func ghetty_Logger_ShouldWrite_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_ghetty_Logger(handle)
	op.ShouldWrite = boolPyToGo(val)
}

//export ghetty_Logger_Log
func ghetty_Logger_Log(_handle CGoHandle, framerate C.double, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Logger")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ghetty.Logger{})).(*ghetty.Logger).Log(float64(framerate))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ghetty.Logger{})).(*ghetty.Logger).Log(float64(framerate))
	}
}

//export ghetty_Logger_Close
func ghetty_Logger_Close(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Logger")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ghetty.Logger{})).(*ghetty.Logger).Close()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ghetty.Logger{})).(*ghetty.Logger).Close()
	}
}

// --- wrapping struct: ghetty.ProcessedTriangle ---
//
//export ghetty_ProcessedTriangle_CTor
func ghetty_ProcessedTriangle_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ghetty_ProcessedTriangle(&ghetty.ProcessedTriangle{}))
}

//export ghetty_ProcessedTriangle_Triangle_Get
func ghetty_ProcessedTriangle_Triangle_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ghetty_ProcessedTriangle(handle)
	return handleFromPtr_Ptr_ghetty_Triangle(op.Triangle)
}

//export ghetty_ProcessedTriangle_Triangle_Set
func ghetty_ProcessedTriangle_Triangle_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_ghetty_ProcessedTriangle(handle)
	op.Triangle = ptrFromHandle_Ptr_ghetty_Triangle(val)
}

//export ghetty_ProcessedTriangle_Bounds_Get
func ghetty_ProcessedTriangle_Bounds_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ghetty_ProcessedTriangle(handle)
	return handleFromPtr_ghetty_Vertex(&op.Bounds)
}

//export ghetty_ProcessedTriangle_Bounds_Set
func ghetty_ProcessedTriangle_Bounds_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_ghetty_ProcessedTriangle(handle)
	op.Bounds = deptrFromHandle_ghetty_Vertex(val)
}

//export ghetty_ProcessedTriangle_VS1_Get
func ghetty_ProcessedTriangle_VS1_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ghetty_ProcessedTriangle(handle)
	return handleFromPtr_ghetty_Vertex(&op.VS1)
}

//export ghetty_ProcessedTriangle_VS1_Set
func ghetty_ProcessedTriangle_VS1_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_ghetty_ProcessedTriangle(handle)
	op.VS1 = deptrFromHandle_ghetty_Vertex(val)
}

//export ghetty_ProcessedTriangle_VS2_Get
func ghetty_ProcessedTriangle_VS2_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ghetty_ProcessedTriangle(handle)
	return handleFromPtr_ghetty_Vertex(&op.VS2)
}

//export ghetty_ProcessedTriangle_VS2_Set
func ghetty_ProcessedTriangle_VS2_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_ghetty_ProcessedTriangle(handle)
	op.VS2 = deptrFromHandle_ghetty_Vertex(val)
}

//export ghetty_ProcessedTriangle_Span_Get
func ghetty_ProcessedTriangle_Span_Get(handle CGoHandle) C.float {
	op := ptrFromHandle_ghetty_ProcessedTriangle(handle)
	return C.float(op.Span)
}

//export ghetty_ProcessedTriangle_Span_Set
func ghetty_ProcessedTriangle_Span_Set(handle CGoHandle, val C.float) {
	op := ptrFromHandle_ghetty_ProcessedTriangle(handle)
	op.Span = float32(val)
}

//export ghetty_ProcessedTriangle_Split_Get
func ghetty_ProcessedTriangle_Split_Get(handle CGoHandle) C.float {
	op := ptrFromHandle_ghetty_ProcessedTriangle(handle)
	return C.float(op.Split)
}

//export ghetty_ProcessedTriangle_Split_Set
func ghetty_ProcessedTriangle_Split_Set(handle CGoHandle, val C.float) {
	op := ptrFromHandle_ghetty_ProcessedTriangle(handle)
	op.Split = float32(val)
}

// --- wrapping struct: ghetty.Shader ---
//
//export ghetty_Shader_CTor
func ghetty_Shader_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ghetty_Shader(&ghetty.Shader{}))
}

// --- wrapping struct: ghetty.Texture ---
//
//export ghetty_Texture_CTor
func ghetty_Texture_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ghetty_Texture(&ghetty.Texture{}))
}

//export ghetty_Texture_Width_Get
func ghetty_Texture_Width_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_ghetty_Texture(handle)
	return C.longlong(op.Width)
}

//export ghetty_Texture_Width_Set
func ghetty_Texture_Width_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_ghetty_Texture(handle)
	op.Width = int(val)
}

//export ghetty_Texture_Height_Get
func ghetty_Texture_Height_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_ghetty_Texture(handle)
	return C.longlong(op.Height)
}

//export ghetty_Texture_Height_Set
func ghetty_Texture_Height_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_ghetty_Texture(handle)
	op.Height = int(val)
}

//export ghetty_Texture_Data_Get
func ghetty_Texture_Data_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ghetty_Texture(handle)
	return handleFromPtr_Slice_byte(&op.Data)
}

//export ghetty_Texture_Data_Set
func ghetty_Texture_Data_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_ghetty_Texture(handle)
	op.Data = deptrFromHandle_Slice_byte(val)
}

//export ghetty_Texture_ConvertPosition
func ghetty_Texture_ConvertPosition(_handle CGoHandle, uv CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Texture")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(ghetty.Texture{})).(*ghetty.Texture).ConvertPosition(ptrFromHandle_Ptr_ghetty_Vertex(uv)))

}

// --- wrapping struct: ghetty.Tile ---
//
//export ghetty_Tile_CTor
func ghetty_Tile_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ghetty_Tile(&ghetty.Tile{}))
}

//export ghetty_Tile_Frame_Get
func ghetty_Tile_Frame_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ghetty_Tile(handle)
	return handleFromPtr_Slice_byte(&op.Frame)
}

//export ghetty_Tile_Frame_Set
func ghetty_Tile_Frame_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_ghetty_Tile(handle)
	op.Frame = deptrFromHandle_Slice_byte(val)
}

//export ghetty_Tile_Depth_Get
func ghetty_Tile_Depth_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ghetty_Tile(handle)
	return handleFromPtr_Slice_float32(&op.Depth)
}

//export ghetty_Tile_Depth_Set
func ghetty_Tile_Depth_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_ghetty_Tile(handle)
	op.Depth = deptrFromHandle_Slice_float32(val)
}

//export ghetty_Tile_Triangles_Get
func ghetty_Tile_Triangles_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ghetty_Tile(handle)
	return handleFromPtr_Slice_Ptr_ghetty_ProcessedTriangle(&op.Triangles)
}

//export ghetty_Tile_Triangles_Set
func ghetty_Tile_Triangles_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_ghetty_Tile(handle)
	op.Triangles = deptrFromHandle_Slice_Ptr_ghetty_ProcessedTriangle(val)
}

//export ghetty_Tile_X_Get
func ghetty_Tile_X_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_ghetty_Tile(handle)
	return C.longlong(op.X)
}

//export ghetty_Tile_X_Set
func ghetty_Tile_X_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_ghetty_Tile(handle)
	op.X = int(val)
}

//export ghetty_Tile_Y_Get
func ghetty_Tile_Y_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_ghetty_Tile(handle)
	return C.longlong(op.Y)
}

//export ghetty_Tile_Y_Set
func ghetty_Tile_Y_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_ghetty_Tile(handle)
	op.Y = int(val)
}

//export ghetty_Tile_Barycentric
func ghetty_Tile_Barycentric(_handle CGoHandle, triangle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Tile")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ghetty.Tile{})).(*ghetty.Tile).Barycentric(ptrFromHandle_Ptr_ghetty_ProcessedTriangle(triangle))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ghetty.Tile{})).(*ghetty.Tile).Barycentric(ptrFromHandle_Ptr_ghetty_ProcessedTriangle(triangle))
	}
}

//export ghetty_Tile_EdgeTest
func ghetty_Tile_EdgeTest(_handle CGoHandle, triangle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Tile")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ghetty.Tile{})).(*ghetty.Tile).EdgeTest(ptrFromHandle_Ptr_ghetty_ProcessedTriangle(triangle))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ghetty.Tile{})).(*ghetty.Tile).EdgeTest(ptrFromHandle_Ptr_ghetty_ProcessedTriangle(triangle))
	}
}

//export ghetty_Tile_SweepLine
func ghetty_Tile_SweepLine(_handle CGoHandle, triangle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Tile")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ghetty.Tile{})).(*ghetty.Tile).SweepLine(ptrFromHandle_Ptr_ghetty_ProcessedTriangle(triangle))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ghetty.Tile{})).(*ghetty.Tile).SweepLine(ptrFromHandle_Ptr_ghetty_ProcessedTriangle(triangle))
	}
}

//export ghetty_Tile_Rasterize
func ghetty_Tile_Rasterize(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Tile")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ghetty.Tile{})).(*ghetty.Tile).Rasterize()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ghetty.Tile{})).(*ghetty.Tile).Rasterize()
	}
}

//export ghetty_Tile_Reset
func ghetty_Tile_Reset(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Tile")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ghetty.Tile{})).(*ghetty.Tile).Reset()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ghetty.Tile{})).(*ghetty.Tile).Reset()
	}
}

//export ghetty_Tile_Add
func ghetty_Tile_Add(_handle CGoHandle, triangle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Tile")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ghetty.Tile{})).(*ghetty.Tile).Add(ptrFromHandle_Ptr_ghetty_ProcessedTriangle(triangle))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ghetty.Tile{})).(*ghetty.Tile).Add(ptrFromHandle_Ptr_ghetty_ProcessedTriangle(triangle))
	}
}

//export ghetty_Tile_ConvertPosition
func ghetty_Tile_ConvertPosition(_handle CGoHandle, x C.longlong, y C.longlong) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Tile")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(ghetty.Tile{})).(*ghetty.Tile).ConvertPosition(int(x), int(y)))

}

//export ghetty_Tile_Set
func ghetty_Tile_Set(_handle CGoHandle, position C.longlong, r C.char, g C.char, b C.char, depth C.float, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Tile")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ghetty.Tile{})).(*ghetty.Tile).Set(int(position), byte(r), byte(g), byte(b), float32(depth))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ghetty.Tile{})).(*ghetty.Tile).Set(int(position), byte(r), byte(g), byte(b), float32(depth))
	}
}

//export ghetty_Tile_Clear
func ghetty_Tile_Clear(_handle CGoHandle, r C.char, g C.char, b C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Tile")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ghetty.Tile{})).(*ghetty.Tile).Clear(byte(r), byte(g), byte(b))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ghetty.Tile{})).(*ghetty.Tile).Clear(byte(r), byte(g), byte(b))
	}
}

// ---- Slices ---

// --- wrapping slice: ghetty.Matrix ---
//
//export ghetty_Matrix_CTor
func ghetty_Matrix_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ghetty_Matrix(&ghetty.Matrix{}))
}

//export ghetty_Matrix_len
func ghetty_Matrix_len(handle CGoHandle) int {
	return len(deptrFromHandle_ghetty_Matrix(handle))
}

//export ghetty_Matrix_elem
func ghetty_Matrix_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_ghetty_Matrix(handle)
	return handleFromPtr_Slice_float32(s[_idx])
}

//export ghetty_Matrix_subslice
func ghetty_Matrix_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_ghetty_Matrix(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_ghetty_Matrix(&ss))
}

//export ghetty_Matrix_set
func ghetty_Matrix_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_ghetty_Matrix(handle)
	s[_idx] = deptrFromHandle_Slice_float32(_vl)
}

//export ghetty_Matrix_append
func ghetty_Matrix_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_ghetty_Matrix(handle)
	*s = append(*s, deptrFromHandle_Slice_float32(_vl))
}

//export ghetty_Matrix_Multiply
func ghetty_Matrix_Multiply(_handle CGoHandle, m2 CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Matrix")
	if __err != nil {
		return handleFromPtr_ghetty_Matrix(nil)
	}
	cret := vifc.(*ghetty.Matrix).Multiply(ptrFromHandle_Ptr_ghetty_Matrix(m2))

	return handleFromPtr_ghetty_Matrix(&cret)
}

//export ghetty_Matrix_Vertex
func ghetty_Matrix_Vertex(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Matrix")
	if __err != nil {
		return handleFromPtr_ghetty_Vertex(nil)
	}
	cret := vifc.(*ghetty.Matrix).Vertex()

	return handleFromPtr_ghetty_Vertex(&cret)
}

// --- wrapping slice: ghetty.Model ---
//
//export ghetty_Model_CTor
func ghetty_Model_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ghetty_Model(&ghetty.Model{}))
}

//export ghetty_Model_len
func ghetty_Model_len(handle CGoHandle) int {
	return len(deptrFromHandle_ghetty_Model(handle))
}

//export ghetty_Model_elem
func ghetty_Model_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_ghetty_Model(handle)
	return handleFromPtr_ghetty_Triangle(&(s[_idx]))
}

//export ghetty_Model_subslice
func ghetty_Model_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_ghetty_Model(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_ghetty_Model(&ss))
}

//export ghetty_Model_set
func ghetty_Model_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_ghetty_Model(handle)
	s[_idx] = *ptrFromHandle_ghetty_Triangle(_vl)
}

//export ghetty_Model_append
func ghetty_Model_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_ghetty_Model(handle)
	*s = append(*s, *ptrFromHandle_ghetty_Triangle(_vl))
}

// --- wrapping slice: ghetty.Vertex ---
//
//export ghetty_Vertex_CTor
func ghetty_Vertex_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ghetty_Vertex(&ghetty.Vertex{}))
}

//export ghetty_Vertex_len
func ghetty_Vertex_len(handle CGoHandle) int {
	return len(deptrFromHandle_ghetty_Vertex(handle))
}

//export ghetty_Vertex_elem
func ghetty_Vertex_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_ghetty_Vertex(handle)
	return C.float(s[_idx])
}

//export ghetty_Vertex_subslice
func ghetty_Vertex_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_ghetty_Vertex(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_ghetty_Vertex(&ss))
}

//export ghetty_Vertex_set
func ghetty_Vertex_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_ghetty_Vertex(handle)
	s[_idx] = float32(_vl)
}

//export ghetty_Vertex_append
func ghetty_Vertex_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_ghetty_Vertex(handle)
	*s = append(*s, float32(_vl))
}

//export ghetty_Vertex_Sum
func ghetty_Vertex_Sum(_handle CGoHandle, v2 CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Vertex")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(*ghetty.Vertex).Sum(ptrFromHandle_Ptr_ghetty_Vertex(v2))
	} else {
		vifc.(*ghetty.Vertex).Sum(ptrFromHandle_Ptr_ghetty_Vertex(v2))
	}
}

//export ghetty_Vertex_Sub
func ghetty_Vertex_Sub(_handle CGoHandle, v2 CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Vertex")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(*ghetty.Vertex).Sub(ptrFromHandle_Ptr_ghetty_Vertex(v2))
	} else {
		vifc.(*ghetty.Vertex).Sub(ptrFromHandle_Ptr_ghetty_Vertex(v2))
	}
}

//export ghetty_Vertex_Multiply
func ghetty_Vertex_Multiply(_handle CGoHandle, v2 CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Vertex")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(*ghetty.Vertex).Multiply(ptrFromHandle_Ptr_ghetty_Vertex(v2))
	} else {
		vifc.(*ghetty.Vertex).Multiply(ptrFromHandle_Ptr_ghetty_Vertex(v2))
	}
}

//export ghetty_Vertex_Transform
func ghetty_Vertex_Transform(_handle CGoHandle, m2 CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Vertex")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(*ghetty.Vertex).Transform(ptrFromHandle_Ptr_ghetty_Matrix(m2))
	} else {
		vifc.(*ghetty.Vertex).Transform(ptrFromHandle_Ptr_ghetty_Matrix(m2))
	}
}

//export ghetty_Vertex_Dot
func ghetty_Vertex_Dot(_handle CGoHandle, v2 CGoHandle) C.float {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Vertex")
	if __err != nil {
		return C.float(0)
	}
	return C.float(vifc.(*ghetty.Vertex).Dot(ptrFromHandle_Ptr_ghetty_Vertex(v2)))

}

//export ghetty_Vertex_Cross
func ghetty_Vertex_Cross(_handle CGoHandle, v2 CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Vertex")
	if __err != nil {
		return handleFromPtr_ghetty_Vertex(nil)
	}
	cret := vifc.(*ghetty.Vertex).Cross(ptrFromHandle_Ptr_ghetty_Vertex(v2))

	return handleFromPtr_ghetty_Vertex(&cret)
}

//export ghetty_Vertex_CrossProduct
func ghetty_Vertex_CrossProduct(_handle CGoHandle, v2 CGoHandle) C.float {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Vertex")
	if __err != nil {
		return C.float(0)
	}
	return C.float(vifc.(*ghetty.Vertex).CrossProduct(ptrFromHandle_Ptr_ghetty_Vertex(v2)))

}

//export ghetty_Vertex_Interpolate
func ghetty_Vertex_Interpolate(_handle CGoHandle, v2 CGoHandle, factor C.float, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Vertex")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(*ghetty.Vertex).Interpolate(ptrFromHandle_Ptr_ghetty_Vertex(v2), float32(factor))
	} else {
		vifc.(*ghetty.Vertex).Interpolate(ptrFromHandle_Ptr_ghetty_Vertex(v2), float32(factor))
	}
}

//export ghetty_Vertex_InsideClipSpace
func ghetty_Vertex_InsideClipSpace(_handle CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Vertex")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(vifc.(*ghetty.Vertex).InsideClipSpace())

}

//export ghetty_Vertex_ScreenSpace
func ghetty_Vertex_ScreenSpace(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Vertex")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(*ghetty.Vertex).ScreenSpace()
	} else {
		vifc.(*ghetty.Vertex).ScreenSpace()
	}
}

//export ghetty_Vertex_Normalize
func ghetty_Vertex_Normalize(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Vertex")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(*ghetty.Vertex).Normalize()
	} else {
		vifc.(*ghetty.Vertex).Normalize()
	}
}

//export ghetty_Vertex_Matrix
func ghetty_Vertex_Matrix(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Vertex")
	if __err != nil {
		return handleFromPtr_ghetty_Matrix(nil)
	}
	cret := vifc.(*ghetty.Vertex).Matrix()

	return handleFromPtr_ghetty_Matrix(&cret)
}

//export ghetty_Vertex_Swap
func ghetty_Vertex_Swap(_handle CGoHandle, v2 CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Vertex")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(*ghetty.Vertex).Swap(ptrFromHandle_Ptr_ghetty_Vertex(v2))
	} else {
		vifc.(*ghetty.Vertex).Swap(ptrFromHandle_Ptr_ghetty_Vertex(v2))
	}
}

//export ghetty_Vertex_Copy
func ghetty_Vertex_Copy(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ghetty.Vertex")
	if __err != nil {
		return handleFromPtr_ghetty_Vertex(nil)
	}
	cret := vifc.(*ghetty.Vertex).Copy()

	return handleFromPtr_ghetty_Vertex(&cret)
}

// ---- Maps ---

// ---- Constructors ---

//export ghetty_NewLogger
func ghetty_NewLogger(directory *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := ghetty.NewLogger(C.GoString(directory))

	return handleFromPtr_ghetty_Logger(&cret)
}

//export ghetty_Process
func ghetty_Process(triangle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := ghetty.Process(ptrFromHandle_Ptr_ghetty_Triangle(triangle))

	return handleFromPtr_ghetty_ProcessedTriangle(&cret)
}

//export ghetty_LoadTexture
func ghetty_LoadTexture(directory *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := ghetty.LoadTexture(C.GoString(directory))

	return handleFromPtr_ghetty_Texture(&cret)
}

// ---- Functions ---

//export ghetty_Launch
func ghetty_Launch(renderCallback *C.PyObject, goRun C.char) {
	_fun_arg := renderCallback
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	if boolPyToGo(goRun) {
		go ghetty.Launch(func() string {
			if C.PyCallable_Check(_fun_arg) == 0 {
				return C.GoString(nil)
			}
			_gstate := C.PyGILState_Ensure()
			_fcret := C.PyObject_CallObject(_fun_arg, nil)
			C.gopy_err_handle()
			C.PyGILState_Release(_gstate)
			return C.GoString(C.PyBytes_AsString(_fcret))
		})
	} else {
		ghetty.Launch(func() string {
			if C.PyCallable_Check(_fun_arg) == 0 {
				return C.GoString(nil)
			}
			_gstate := C.PyGILState_Ensure()
			_fcret := C.PyObject_CallObject(_fun_arg, nil)
			C.gopy_err_handle()
			C.PyGILState_Release(_gstate)
			return C.GoString(C.PyBytes_AsString(_fcret))
		})
	}
}

//export ghetty_LoadModel
func ghetty_LoadModel(directory *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := ghetty.LoadModel(C.GoString(directory))

	return handleFromPtr_ghetty_Model(&cret)
}

//export ghetty_TransformationMatrix
func ghetty_TransformationMatrix(p CGoHandle, r CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := ghetty.TransformationMatrix(deptrFromHandle_ghetty_Vertex(p), deptrFromHandle_ghetty_Vertex(r))

	return handleFromPtr_ghetty_Matrix(&cret)
}

//export ghetty_Clamp
func ghetty_Clamp(value C.float, min C.longlong, max C.longlong) C.float {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.float(ghetty.Clamp(float32(value), int(min), int(max)))

}

//export ghetty_BuildAndProcess
func ghetty_BuildAndProcess(triangle CGoHandle, tiles CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	if boolPyToGo(goRun) {
		go ghetty.BuildAndProcess(ptrFromHandle_Ptr_ghetty_Triangle(triangle), ptrFromHandle_Ptr_Slice_Slice_ghetty_Tile(tiles))
	} else {
		ghetty.BuildAndProcess(ptrFromHandle_Ptr_ghetty_Triangle(triangle), ptrFromHandle_Ptr_Slice_Slice_ghetty_Tile(tiles))
	}
}

//export ghetty_ProjectionMatrix
func ghetty_ProjectionMatrix() CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := ghetty.ProjectionMatrix()

	return handleFromPtr_ghetty_Matrix(&cret)
}

//export ghetty_BasicVertex
func ghetty_BasicVertex(vertex CGoHandle, uv CGoHandle, normal CGoHandle, color CGoHandle, matrices CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	if boolPyToGo(goRun) {
		go ghetty.BasicVertex(ptrFromHandle_Ptr_ghetty_Vertex(vertex), ptrFromHandle_Ptr_ghetty_Vertex(uv), ptrFromHandle_Ptr_ghetty_Vertex(normal), ptrFromHandle_Ptr_ghetty_Vertex(color), deptrFromHandle_Slice_Ptr_ghetty_Matrix(matrices)...)
	} else {
		ghetty.BasicVertex(ptrFromHandle_Ptr_ghetty_Vertex(vertex), ptrFromHandle_Ptr_ghetty_Vertex(uv), ptrFromHandle_Ptr_ghetty_Vertex(normal), ptrFromHandle_Ptr_ghetty_Vertex(color), deptrFromHandle_Slice_Ptr_ghetty_Matrix(matrices)...)
	}
}
