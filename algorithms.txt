/*func (tile *Tile) EdgeTest(triangle *TriangleSpan) {
	for y := tile.Y; y < tile.Y+TileYSize-1; y++ {
		for x := tile.X; x < tile.X+TileXSize-1; x++ {

			var w0, w1, w2 float32 = triangle.EdgeSpan(x, y)

			if w0 >= 0 && w1 >= 0 && w2 >= 0 {
				var s, t, w float32 = triangle.Barycentric(x, y)
				var r, g, b float32 = shader(s, t, w)

				tile.Set(x, y, byte(r*255), byte(g*255), byte(b*255))
			}
		}
	}
}*/

/*func (tile *Tile) SweepLine(triangle *TriangleSpan) {
	var invSlope1 float32 = (triangle.Vertices[1][X] - triangle.Vertices[0][X]) /
		(triangle.Vertices[1][Y] - triangle.Vertices[0][Y])

	var invSlope2 float32 = (split - triangle.Vertices[0][X]) /
		(triangle.Vertices[1][Y] - triangle.Vertices[0][Y])

	var clampedUp float32 = Clamp(triangle.Vertices[0][Y], ty, ty+TileYSize)
	var clampedMiddle float32 = Clamp(triangle.Vertices[1][Y], ty, ty+TileYSize)
	var clampedDown float32 = Clamp(triangle.Vertices[2][Y], ty, ty+TileYSize)

	var difference float32 = clampedUp - triangle.Vertices[0][Y]
	var curX1, curX2 float32 = triangle.Vertices[0][X] + invSlope1*difference,
		triangle.Vertices[0][X] + invSlope2*difference

	for y := int(clampedUp); y < int(clampedMiddle); y++ {
		for x := int(Clamp(curX1, tx, tx+TileXSize)); x < int(Clamp(curX2, tx, tx+TileXSize)); x++ {
			var s, t, w float32 = triangle.Barycentric(span, x, y)
			var r, g, b float32 = shader(s, t, w)

			tile.Set(x, y, byte(r*255), byte(g*255), byte(b*255))
		}

		curX1 += invSlope1
		curX2 += invSlope2
	}

	invSlope1 = (triangle.Vertices[2][X] - triangle.Vertices[1][X]) /
		(triangle.Vertices[2][Y] - triangle.Vertices[1][Y])

	invSlope2 = (triangle.Vertices[2][X] - split) /
		(triangle.Vertices[2][Y] - triangle.Vertices[1][Y])

	difference = triangle.Vertices[2][Y] - clampedDown
	curX1, curX2 = triangle.Vertices[2][X]-invSlope1*difference, triangle.Vertices[2][X]-invSlope2*difference

	for y := int(clampedDown) - 1; y > int(clampedMiddle)-1; y-- {
		for x := int(Clamp(curX1, tx, tx+TileXSize)); x < int(Clamp(curX2, tx, tx+TileXSize)); x++ {
			var s, t, w float32 = triangle.Barycentric(span, x, y)
			var r, g, b float32 = shader(s, t, w)

			tile.Set(x, y, byte(r*255), byte(g*255), byte(b*255))
		}

		curX1 -= invSlope1
		curX2 -= invSlope2
	}
}*/